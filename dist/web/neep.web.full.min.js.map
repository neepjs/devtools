{"version":3,"file":"neep.web.full.min.js","sources":["../../src/core/constant.ts","../../src/core/install.ts","../../src/core/Error.ts","../../src/core/auxiliary/tags.ts","../../src/core/auxiliary/state.ts","../../src/core/helper/current.ts","../../src/core/helper/context.ts","../../src/core/hook.ts","../../src/core/auxiliary/life.ts","../../src/core/symbols.ts","../../src/core/auxiliary/element.ts","../../src/core/auxiliary/dev.ts","../../src/core/auxiliary/index.ts","../../src/core/render/id.ts","../../src/core/render/recursive.ts","../../src/core/render/draw.ts","../../src/core/render/slot.ts","../../src/core/render/props.ts","../../src/core/render/normalize.ts","../../src/core/render/Object.ts","../../src/core/render/Entity.ts","../../src/core/render/convert.ts","../../src/core/render/Container.ts","../../src/core/create.ts","../../src/web/update.ts","../../src/web/index.ts","../../node_modules/monitorable/dist/monitorable.esm.js","../../src/web/full.ts","../../src/core/render/index.ts"],"sourcesContent":["/**\n * Global constant\n *\n * Will be replaced by the 'rollup-plugin-replace' plug-in\n */\n\n /**\n * Neep code version\n */\nexport const version = '__VERSION__' as string;\n/**\n * Current mode\n * @enum production\n * @enum development\n */\nexport const mode = '__MODE__' as any as 'production' | 'development';\n/**\n * Is the current mode production mode\n * @description Support tree shaking\n */\nexport const isProduction = mode === 'production';\n","import * as monitorableApi from 'monitorable';\nimport { IRender } from './type';\nimport { isProduction } from './constant';\n\nimport { Devtools } from '../devtools/type';\n\nexport let monitorable: typeof monitorableApi;\n\nexport interface InstallOptions {\n\tmonitorable?: typeof monitorableApi;\n\trender?: IRender;\n\trenders?: IRender[];\n\tdevtools?: any;\n}\n\nexport const renders: Record<string, IRender>\n\t= Object.create(null);\n\n\texport function getRender(\n\ttype: string | number | IRender = ''\n\t): IRender {\n\tif (typeof type === 'object') { return type; }\n\treturn renders[type] || renders.default;\n}\n\nfunction installRender({ render, renders: list}: InstallOptions) {\n\tif (render) {\n\t\trenders[render.type] = render;\n\t\tif (!renders.default) {\n\t\t\trenders.default = render;\n\t\t}\n\t}\n\tif (Array.isArray(list)) {\n\t\tfor (const render of list) {\n\t\t\trenders[render.type] = render;\n\t\t}\n\t\tif (!renders.default) {\n\t\t\tconst [render] = list;\n\t\t\tif (render) { renders.default = render; }\n\t\t}\n\t}\n}\n\nexport const devtools: Devtools = {\n\trenderHook(){},\n};\n\nfunction installDevtools(tools?: Partial<Devtools>) {\n\tif (!tools) { return; }\n\tif (typeof tools !== 'object') { return; }\n\tconst { renderHook } = tools;\n\tif (typeof renderHook === 'function') {\n\t\tdevtools.renderHook = renderHook;\n\t}\n}\n\nexport default function install(apis: InstallOptions) {\n\tif (apis.monitorable) {\n\t\tmonitorable = apis.monitorable;\n\t}\n\tinstallRender(apis);\n\tif (!isProduction) {\n\t\tinstallDevtools(apis.devtools);\n\t}\n}\n","export default class NeepError extends Error {\n\treadonly tag: string;\n\tconstructor(message: string, tag: string = '') {\n\t\tsuper(tag ? `[${tag}] ${message}` : message);\n\t\tthis.tag = tag;\n\t}\n}\n","export const ScopeSlot = 'Neep:ScopeSlot';\nexport const SlotRender = 'Neep:SlotRender';\nexport const Slot = 'Neep:Slot';\nexport const Value = 'Neep:Value';\nexport const Container = 'Neep:Container';\nexport const Deliver = 'Neep:Deliver';\nexport const Template = 'template';\nexport const Fragment = Template;\n","/**\n * 状态管理类 API\n */\nimport { Value, Options } from 'monitorable';\nimport { monitorable } from '../install';\n\nexport function value<T>(\n\tvalue: T,\n\toptions?: boolean | Options,\n): Value<T>\nexport function value(...v: [any]) {\n\treturn monitorable.value(...v);\n}\nexport function computed<T>(\n\tgetter: () => T,\n\toptions?: boolean | Options,\n): Value<T>;\nexport function computed<T>(...v: [any]) {\n\treturn monitorable.computed(...v);\n}\nexport function isValue(v: any): v is Value<any>;\nexport function isValue(...v: [any]) {\n\treturn monitorable.isValue(...v);\n}\nexport function encase<T>(value: T, nest?: number | boolean): T;\nexport function encase<T>(...v: [any]): T {\n\treturn monitorable.encase(...v);\n}\nexport function recover<T>(v: T): T;\nexport function recover<T>(...v: [any]): T {\n\treturn monitorable.recover(...v);\n}\n","import NeepError from '../Error';\nimport { Entity } from '../type';\n\n/** 当前正在执行的对象 */\nexport let current: Entity | undefined;\nexport function setCurrent<T>(\n\tfn: () => T,\n\tentity: Entity,\n): T {\n\tconst oldEntity = current;\n\tcurrent = entity;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tcurrent = oldEntity;\n\t}\n}\n\nexport function checkCurrent(\n\tname: string,\n\tinitOnly = false,\n): Entity {\n\tif (!current) {\n\t\tthrow new NeepError(\n\t\t\t`Function \\`${name}\\` can only be called within a cycle.`,\n\t\t\t'life',\n\t\t);\n\t}\n\tif (!initOnly) {\n\t\treturn current;\n\t}\n\tif (!current.created) {\n\t\treturn current;\n\t}\n\tthrow new NeepError(\n\t\t`Function \\`${name}\\` can only be called at initialization time.`,\n\t\t'life',\n\t);\n}\n","import { Context, ContextConstructor, Exposed } from '../type';\nimport { monitorable } from '../install';\n\nconst constructors: ContextConstructor[] = [];\nexport function initContext(\n\tcontext: Context,\n\texposed?: Exposed,\n): Context {\n\tfor (const constructor of constructors) {\n\t\tconstructor(context, exposed);\n\t}\n\treturn context;\n}\nexport function addContextConstructor(\n\tconstructor: ContextConstructor\n): void {\n\tconstructors.push(monitorable.safeify(constructor));\n}","import { monitorable } from './install';\nimport { Hook, Hooks, Entity } from './type';\nconst hooks: Record<string, Set<Hook>> = Object.create(null);\n\nexport function setHook<H extends Hooks>(\n\tid: H,\n\thook: Hook,\n\tentity?: Entity,\n):() => void;\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n): () => void;\n\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n):() => void {\n\tlet list = entity?.$_hooks || hooks;\n\tif (!list) { return () => {}; }\n\thook = monitorable.safeify(hook);\n\tlet set = list[id];\n\tif (!set) {\n\t\tset = new Set();\n\t\tlist[id] = set;\n\t}\n\tset.add(hook);\n\treturn () => set.delete(hook);\n}\n\nexport function callHook<H extends Hooks>(\n\tid: H,\n\texposed: Entity,\n): void;\nexport function callHook(id: string, exposed: Entity): void;\nexport function callHook(id: string, exposed: Entity): void {\n\tif (!exposed) { return; }\n\tfor (const hook of exposed.$_hooks[id] || []) {\n\t\thook(exposed);\n\t}\n\tfor (const hook of hooks[id] || []) {\n\t\thook(exposed);\n\t}\n}\n","/**********************************\n * 组件上下文环境专用 API\n * @description 简单组件不支持\n **********************************/\nimport { Value, WatchCallback } from 'monitorable';\nimport { Hooks, Hook } from '../type';\nimport { checkCurrent } from '../helper';\nimport { monitorable } from '../install';\nimport { setHook } from '../hook';\nimport { isValue } from './state';\n\n\n/**********************************\n * 状态管理类 API\n **********************************/\n/**\n * 监听指定值的变化\n * @description 本质是调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 被监听的值\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: Value<T>,\n\tcb: WatchCallback<T>,\n): () => void;\n/**\n * 监听指定值的变化\n * @description 本质是创建调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 用于计算观测值的函数\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: () => T,\n\tcb: (v: T, stopped: boolean) => void,\n): () => void;\n\nexport function watch<T>(\n\tvalue: Value<T> | (() => T),\n\tcb: (v: Value<T> | T, stopped: boolean) => void\n): () => void {\n\tconst entity = checkCurrent('watch');\n\tif (typeof value !== 'function') { return () => {}; }\n\tconst stop = isValue(value)\n\t\t? value.watch(cb)\n\t\t: monitorable.computed(value).watch((v, s) => cb(v(), s));\n\tsetHook('beforeDestroy', () => stop(), entity);\n\treturn stop;\n}\n\n\n/**********************************\n * 钩子类 API\n **********************************/\n/**\n * 为当前组件注册钩子\n * @param name 钩子名称\n * @param hook 钩子\n * @param initOnly 是否仅在初始化时有效\n */\nexport function hook<H extends Hooks>(\n\tname: H,\n\thook: Hook,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: Hook,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: Hook,\n\tinitOnly?: boolean,\n): undefined | (() => void) {\n\tconst entity = checkCurrent('setHook');\n\tif (initOnly && entity.created) { return undefined; }\n\treturn setHook(name, hook, entity);\n}\n\n/**********************************\n * 配置 API\n **********************************/\n\nexport function setValue<T>(\n\tobj: any,\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tif (\n\t\ttypeof name === 'string'\n\t\t&& ['$', '_'].includes(name[0])\n\t) {\n\t\treturn;\n\t}\n\tif (isValue(value) && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget() { return value(); },\n\t\t\tset(v) { value(v); },\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tif (typeof value === 'function' && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget: value as () => T,\n\t\t\tset: typeof opt === 'function' ? opt : undefined,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tReflect.defineProperty(obj, name, {\n\t\tget() { return value; },\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\n\n\n\n/**********************************\n * 配置 API\n **********************************/\n\n/**\n * 将 Value 导出\n * @param name 导出用的名称\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的导出\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的导出\n * @param name\n * @param getter\n * @param setter\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('expose', true).exposed, name, value, opt);\n}\n\n/**********************************\n * 配置 API\n **********************************/\n\n/**\n * 将 Value 传递给子组件\n * @param name 导出用的名称\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的传递\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的传递\n * @param name\n * @param getter\n * @param setter\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('deliver', true).delivered, name, value, opt);\n}\n","export const isElementSymbol = Symbol.for('isNeepElement');\nexport const typeSymbol = Symbol.for('type');\nexport const nameSymbol = Symbol.for('name');\nexport const renderSymbol = Symbol.for('render');\n","import { Tag, NeepElement, Component } from '../type';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport * as Tags from './tags';\n\n/**\n * 判读是否为元素\n */\nexport function isElement(v: any): v is NeepElement {\n\tif (!v) { return false; }\n\tif (typeof v !== 'object') { return false; }\n\treturn v[isElementSymbol] === true;\n}\n\nexport function createElement(\n\ttag: Tag,\n\tattrs?: {[key:string]: any},\n\t...children: any[]\n): NeepElement {\n\tattrs = attrs ? {...attrs} : {};\n\tconst node: NeepElement = {\n\t\t[isElementSymbol]: true,\n\t\ttag,\n\t\tchildren: [],\n\t};\n\tif ('key' in attrs) { node.key = attrs.key; }\n\tif ('slot' in attrs) { node.slot = attrs.slot; }\n\tif (typeof attrs.ref === 'function') { node.ref = attrs.ref; }\n\tif (tag === Tags.Value) {\n\t\tnode.value = attrs.value;\n\t\treturn node;\n\t}\n\tnode.children = children;\n\tif (tag === Tags.Template) { return node; }\n\tif (tag === Tags.SlotRender) {\n\t\tnode.render = attrs.render;\n\t\treturn node;\n\t}\n\tif (tag === Tags.ScopeSlot || tag === Tags.Slot) {\n\t\tconst { render, argv, args, name } = attrs;\n\t\tnode.render = render;\n\t\tnode.args = argv && [argv]\n\t\t\t|| Array.isArray(args) && args.length && args\n\t\t\t|| [{}];\n\n\t\tif (tag === Tags.ScopeSlot) {\n\t\t\tnode.props = { name };\n\t\t\treturn node;\n\t\t}\n\t}\n\tnode.on = {};\n\tnode.props = {};\n\tfor (let k in attrs) {\n\t\t/** 事件 */\n\t\tconst onInfo = /^(::|@|on:)([a-zA-Z0-9].*)$/.exec(k);\n\t\tif (onInfo) {\n\t\t\tnode.on[onInfo[2]] = attrs[k];\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: data\n\t\tconst nCmd = /^n([:-])([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*)$/i.exec(k);\n\t\t/** 普通属性 */\n\t\tif (!nCmd) {\n\t\t\tnode.props[k] = attrs[k];\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn node;\n}\n\nexport interface elementIteratorOptions {\n\tsimple?: boolean | Component[] | ((c: Component) => boolean);\n}\n\nexport function elements(\n\tnode: any,\n\topt: elementIteratorOptions = {},\n): any[] {\n\tif (Array.isArray(node)) {\n\t\tconst list: any[][] = [];\n\t\tfor (let n of node) {\n\t\t\tlist.push(elements(n, opt));\n\t\t}\n\t\treturn ([] as any[]).concat(...list);\n\t}\n\tif (!isElement(node)) { return [node]; }\n\tlet { tag } = node;\n\tif (!tag) { return []; }\n\n\tif (([Tags.Template, Tags.ScopeSlot] as Tag[]).includes(tag)) {\n\t\treturn elements(node.children, opt);\n\t}\n\tif (typeof tag !== 'function') { return [node]; }\n\tif (tag[typeSymbol] !== 'simple') { return [node]; }\n\tconst { simple } = opt;\n\tif (!simple) { return [node]; }\n\tif (Array.isArray(simple)) {\n\t\tif (simple.includes(tag)) { return [node]; }\n\t} else if (typeof simple === 'function') {\n\t\tif (!simple(tag)) { return [node]; }\n\t}\n\treturn elements(node.children, opt);\n}\n","import { isProduction } from '../constant';\nimport { current } from '../helper';\nimport { setLabel } from '../helper/label';\n\nexport function label(text: string, color = ''): void {\n\tif (!isProduction) {\n\t\tif (!current) {\n\t\t\tsetLabel([text, color]);\n\t\t\treturn;\n\t\t}\n\t\tReflect.defineProperty(current.exposed, '$label', {\n\t\t\tvalue: [text, color],\n\t\t\tconfigurable: true,\n\t\t});\n\t}\n}\n","import * as Constant from '../constant';\nimport * as Tags from './tags';\nimport * as State from './state';\nimport * as Life from './life';\nimport * as Element from './element';\nimport * as Dev from './dev';\n\nexport * from './tags';\nexport * from './state';\nexport * from './life';\nexport * from './element';\nexport * from './dev';\n\nexport { Tags };\n\n\n/** 辅助 */\nexport interface Auxiliary extends\n\tReadonly<typeof Tags>,\n\tReadonly<typeof State>,\n\tReadonly<typeof Life>,\n\tReadonly<typeof Element>,\n\tReadonly<typeof Dev>,\n\tReadonly<typeof Constant>\n{}\n\nconst auxiliary: Auxiliary = {\n\t...Tags,\n\t...State,\n\t...Life,\n\t...Element,\n\t...Dev,\n\t...Constant,\n};\n\nexport function setAuxiliary<T>(\n\tname: string,\n\tvalue: T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tvalue,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport function defineAuxiliary<T>(\n\tname: string,\n\tget: (this: Auxiliary) => T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tget,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport default auxiliary;\n","import { NativeNode } from '../type';\nimport { isProduction } from '../constant';\nimport { MountedNode } from './draw';\n\nlet ids = 0;\nconst Nodes: {[key: number]: MountedNode} = {};\nlet IdMap: undefined | Map<NativeNode, number>;\nif (!isProduction) {\n\tIdMap = new Map();\n}\nexport function createMountedNode(\n\tn: Omit<MountedNode, 'id'>,\n\tid?: number,\n): MountedNode {\n\tif (!isProduction) {\n\t\tid = id || ++ids;\n\t\tconst { node } = n;\n\t\tif (node && IdMap) { IdMap.set(node, id); }\n\t\treturn Nodes[id] = {...n, id};\n\t}\n\treturn {...n, id: 0};\n}\n\nexport function recoveryMountedNode(node: MountedNode): void {\n\tif (!isProduction) {\n\t\tdelete Nodes[node.id];\n\t}\n}\n\nexport function getNode(\n\tid: number | NativeNode,\n): MountedNode | undefined {\n\tif (!isProduction) {\n\t\tif (typeof id !== 'number') {\n\t\t\tid = IdMap?.get(id) || -1;\n\t\t}\n\t\treturn Nodes[id];\n\t}\n\treturn undefined;\n}\n","export interface RecursiveArray<T> extends Array<RecursiveItem<T>>{};\nexport type RecursiveItem<T> = T | RecursiveArray<T>;\n\nexport function *recursive2iterable<T>(\n\tlist: RecursiveItem<T>,\n): Iterable<T> {\n\tif (!Array.isArray(list)) {\n\t\tyield list;\n\t\treturn;\n\t}\n\tfor (const it of list) {\n\t\tyield* recursive2iterable(it);\n\t}\n}\n","import { Tags, Template } from '../auxiliary';\nimport { IRender, NativeNode, NativeElement } from '../type';\nimport { createMountedNode, recoveryMountedNode } from './id';\nimport { TreeNode } from './convert';\nimport NeepObject from './Object';\n\n\n/**\n * @description node / component / children 至少一个有效\n */\nexport interface MountedNode extends TreeNode {\n\tid: number;\n\tparent?: this;\n\tnode: undefined | NativeNode;\n}\n\n\ntype MountedNodes = MountedNode | MountedNode[]\n\t| (MountedNode | MountedNode[])[];\n\nfunction getLastNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) {\n\t\treturn getLastNode(tree[tree.length - 1]);\n\t}\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getLastNode(component.tree); }\n\treturn getLastNode(children);\n}\n\nfunction getFirstNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) { return getFirstNode(tree[0]); }\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getFirstNode(component.tree); }\n\treturn getFirstNode(children[0]);\n}\n\nexport function *getNodes(tree: MountedNodes): Iterable<NativeNode> {\n\tif (Array.isArray(tree)) {\n\t\tfor (const it of tree) {\n\t\t\tyield* getNodes(it);\n\t\t}\n\t\treturn;\n\t}\n\tconst { children, node, component } = tree;\n\tif (node) {\n\t\tyield node;\n\t\treturn;\n\t}\n\tif (component) {\n\t\tyield* getNodes(component.tree);\n\t\treturn;\n\t}\n\tyield* getNodes(children);\n}\n\nexport function unmount(iRender: IRender, tree: MountedNodes): void {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(e => unmount(iRender, e));\n\t\treturn;\n\t}\n\tconst { component, children, node, ref } = tree;\n\trecoveryMountedNode(tree);\n\tif (node) {\n\t\tif (ref) { ref(node, true); }\n\t\tiRender.remove(node);\n\t\treturn;\n\t}\n\tif (component) {\n\t\tif (ref) { ref(component.exposed, true); }\n\t\tcomponent.unmount();\n\t\treturn;\n\t}\n\tunmount(iRender, children);\n}\n\n\nfunction replace<T extends MountedNode | MountedNode[]>(\n\tiRender: IRender,\n\tnewTree: T,\n\toldTree: MountedNode | MountedNode[],\n): T {\n\tconst next = getFirstNode(oldTree);\n\tif (!next) { return newTree; }\n\tconst parent = iRender.parent(next);\n\tif (!parent) { return newTree; }\n\tfor (const it of getNodes(newTree)) {\n\t\tiRender.insert(parent, it, next);\n\t}\n\tunmount(iRender, oldTree);\n\treturn newTree;\n}\n\nfunction updateList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n\ttree: MountedNode | MountedNode[],\n): MountedNode[] {\n\tif (!source.length) {\n\t\tconst node = createItem(iRender, {tag: null, children: []});\n\t\treturn [replace(iRender, node, tree)];\n\t}\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: MountedNode[] = [];\n\tconst list = [...tree];\n\tconst mountedMap = new Map<MountedNode, MountedNode>();\n\tfor (const src of source) {\n\t\tconst index = list.findIndex(it =>\n\t\t\tit.tag === src.tag && it.key === src.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tconst old = list[index];\n\t\t\tconst item = updateItem(iRender, src, old);\n\t\t\tmountedMap.set(old, item);\n\t\t\tnewList.push(item);\n\t\t\tlist.splice(index, 1);\n\t\t} else {\n\t\t\tconst item = createItem(iRender, src);\n\t\t\tnewList.push(item);\n\t\t}\n\t}\n\tif (!mountedMap.size) {\n\t\treturn replace(iRender, newList, list);\n\t}\n\tunmount(iRender, list);\n\ttree = tree.filter(t => mountedMap.has(t));\n\tconst last = getLastNode(tree[tree.length - 1]);\n\tconst parent = iRender.parent(last);\n\tif (!parent) { return newList; }\n\tlet next = iRender.next(last);\n\t// 调整次序\n\tfor(let i = newList.length - 1; i >= 0; i--) {\n\t\tconst item = newList[i];\n\t\tconst index = tree.findIndex(o => mountedMap.get(o) === item);\n\t\tif (index >= 0) {\n\t\t\tfor (const it of tree.splice(index)) {\n\t\t\t\tmountedMap.delete(it);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t\tnext = getFirstNode(item) || next;\n\t}\n\treturn newList;\n}\n/**\n * 更新树\n * @param tree 已有树\n * @param source 用于替换的源\n * @param iRender Neep 对象\n */\nfunction updateAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length || 1);\n\tconst list: (MountedNode | MountedNode[])[] = [];\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tlist.push(updateList(iRender, src, tree[index]));\n\t\t} else {\n\t\t\tlist.push(updateItem(iRender, src, tree[index]));\n\t\t}\n\t}\n\tlength = Math.max(source.length, tree.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\tunmount(iRender, tree[index]);\n\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tconst last = getLastNode(list[list.length - 1]);\n\t\tconst parent = iRender.parent(last);\n\t\tconst next = iRender.next(last);\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = source[index];\n\t\t\tconst item = Array.isArray(src)\n\t\t\t\t? createList(iRender, src)\n\t\t\t\t: createItem(iRender, src);\n\t\t\tlist.push(item);\n\t\t\tif (!parent) { continue; }\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\n/**\n * 更新树节点\n * @param iRender Neep 对象\n * @param tree 已有树\n * @param source 用于替换的源\n */\nfunction updateItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n\ttree: MountedNode | MountedNode[],\n): MountedNode {\n\tif (Array.isArray(tree)) {\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === source.tag && it.component === source.component\n\t\t);\n\t\tif (index < 0) {\n\t\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tunmount(iRender, all);\n\t}\n\tconst { tag, component } = source;\n\tconst ref = source.ref !== tree.ref && source.ref;\n\tif (tag !== tree.tag || component !== tree.component) {\n\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t}\n\tif (!tag) { return tree; }\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(\n\t\t\t\t\tiRender,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t}, tree.id);\n\t\t}\n\t\tif (ref) { ref(component.exposed); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent,\n\t\t\tchildren: [],\n\t\t}, tree.id);\n\t}\n\tif (tag === Tags.Value) {\n\t\tif(tree.value === source.value) {\n\t\t\tif (ref && tree.node) { ref(tree.node); }\n\t\t\treturn createMountedNode({\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tchildren: [],\n\t\t\t}, tree.id);\n\t\t}\n\t\treturn replace( iRender, createValue(iRender, source), tree);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: updateAll(\n\t\t\t\tiRender,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t}, tree.id);\n\t}\n\tconst { node } = tree;\n\tiRender.update(\n\t\tnode as NativeElement,\n\t\tsource.props || {},\n\t);\n\tif (ref) { ref(node!); }\n\tif (!source.children.length && !tree.children.length) {\n\t\treturn createMountedNode(\n\t\t\t{\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tchildren: [],\n\t\t\t},\n\t\t\ttree.id);\n\t}\n\tif (!source.children.length && tree.children.length) {\n\t\tunmount(iRender, tree.children);\n\t}\n\tif (source.children.length && !tree.children.length) {\n\t\tconst children = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node as NativeElement, it);\n\t\t}\n\t\treturn createMountedNode({\n\t\t\t...tree,\n\t\t\t...source,\n\t\t\tchildren,\n\t\t}, tree.id);\n\t}\n\treturn createMountedNode({\n\t\t...tree, ...source,\n\t\tchildren: updateAll(\n\t\t\tiRender,\n\t\t\tsource.children,\n\t\t\ttree.children,\n\t\t),\n\t}, tree.id);\n}\n\nfunction createValue(\n\tiRender: IRender,\n\tsource: TreeNode,\n): MountedNode {\n\tconst { value, ref } = source;\n\tif (iRender.isNode(source.value)) {\n\t\tif (ref) { ref(value); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: value,\n\t\t\tchildren: [],\n\t\t\tcomponent: undefined,\n\t\t});\n\t}\n\tconst type = typeof value;\n\tlet node: NativeNode | undefined;\n\tif (\n\t\ttype === 'bigint'\n\t\t|| type === 'boolean'\n\t\t|| type === 'number'\n\t\t|| type === 'string'\n\t\t|| type === 'symbol'\n\t\t|| value instanceof RegExp\n\t) {\n\t\tnode = iRender.text(String(value));\n\t} else if (value instanceof Date) {\n\t\tnode = iRender.text(value.toISOString());\n\t} else if (type === 'object' && value) {\n\t\tnode = iRender.text(String(value));\n\t\t// TODO: 对象处理\n\t}\n\tif (!node) { node = iRender.placeholder(); }\n\tif (ref) { ref(node); }\n\treturn createMountedNode({\n\t\t...source,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t});\n}\n\nfunction createAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (!source.length) {\n\t\treturn [createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode: iRender.placeholder(),\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t})];\n\t}\n\n\treturn source.map(item =>\n\t\tArray.isArray(item)\n\t\t\t? createList(iRender, item)\n\t\t\t: createItem(iRender, item)\n\t);\n}\n\nfunction createList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n): MountedNode[] {\n\tif (source.length) {\n\t\treturn source.map(it => createItem(iRender, it));\n\t}\n\treturn [createMountedNode({\n\t\ttag: null,\n\t\tnode: iRender.placeholder(),\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t})];\n}\n\nfunction createItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n): MountedNode {\n\tconst { tag, ref, component } = source;\n\tif (!tag) {\n\t\tconst node = iRender.placeholder();\n\t\tif (ref) { ref(node); }\n\t\treturn createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t});\n\t}\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(iRender, source.children),\n\t\t\t});\n\t\t}\n\t\tcomponent.mount();\n\t\tif (ref) { ref(component.exposed); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent, children: [],\n\t\t});\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn createValue(iRender, source);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: createAll(iRender, source.children),\n\t\t});\n\t}\n\tconst node = iRender.create(tag, source.props || {});\n\tif (ref) { ref(node); }\n\tlet children: (MountedNode | MountedNode[])[] = [];\n\tif (source.children) {\n\t\tchildren = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node, it);\n\t\t}\n\t}\n\treturn createMountedNode({\n\t\t...source,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren,\n\t});\n}\n\nexport default function draw(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree?: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (tree) {\n\t\treturn updateAll(iRender, source, tree);\n\t}\n\treturn createAll(iRender, source);\n}\n","import { NeepElement, SlotFn, Slots, IRender } from '../type';\nimport { isElement, SlotRender, ScopeSlot } from '../auxiliary';\nimport { isElementSymbol } from '../symbols';\nimport { isProduction } from '../constant';\n\n\nexport function getSlots(\n\tiRender: IRender,\n\tchildren: any[],\n\tslots: Record<string | symbol, any[]>,\n\tnative = false,\n): any[] {\n\t/** 原始对象 */\n\tconst nativeList: any[] = [];\n\tfor (const it of children) {\n\t\tif (Array.isArray(it)) {\n\t\t\tconst list: Record<string | symbol, any[]>\n\t\t\t\t= Object.create(null);\n\t\t\tnativeList.push(getSlots(iRender, it, list, native));\n\t\t\tfor (const k of Reflect.ownKeys(list) as string[]) {\n\t\t\t\tif (k in slots) {\n\t\t\t\t\tslots[k].push(list[k]);\n\t\t\t\t} else {\n\t\t\t\t\tslots[k] = [list[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (native) {\n\t\t\tif (iRender.isNode(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isElement(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (it.tag !== SlotRender) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconst slot = isElement(it) && it.slot || 'default';\n\t\tconst el = isElement(it) ? {\n\t\t\t...it, slot: undefined,\n\t\t\tprops: {...it.props, slot: undefined },\n\t\t} : it;\n\t\tif (slot in slots) {\n\t\t\tslots[slot].push(el);\n\t\t} else {\n\t\t\tslots[slot] = [el];\n\t\t}\n\t}\n\treturn nativeList;\n}\nfunction renderSlots(\n\tlist: any[],\n\t...props: any\n): any[] {\n\treturn list.map(it => {\n\t\tif (Array.isArray(it)) {\n\t\t\treturn renderSlots(it, ...props);\n\t\t}\n\t\tif (!isElement(it)) { return it; }\n\t\tif (it.tag !== SlotRender) {\n\t\t\treturn {\n\t\t\t\t...it,\n\t\t\t\tslot: undefined,\n\t\t\t} as NeepElement;\n\t\t}\n\t\tif (typeof it.render === 'function') {\n\t\t\treturn it.render(...props);\n\t\t}\n\t\treturn it.children;\n\t});\n}\nfunction createSlots(\n\tname: string,\n\tlist: any[],\n): SlotFn {\n\tconst slot = (...props: any) => ({\n\t\t[isElementSymbol]: true,\n\t\ttag: ScopeSlot,\n\t\tchildren: renderSlots(list, ...props),\n\t\tinserted: true,\n\t\tlabel: isProduction ? undefined : [`[${name}]`, '#00F'],\n\t} as NeepElement);\n\tslot.children = list;\n\treturn slot;\n}\nexport function setSlots(\n\tchildren: {[key: string]: any[]},\n\tslots: Slots = Object.create(null),\n) {\n\tfor (const k of Reflect.ownKeys(slots)) {\n\t\tif (!(k in children)) {\n\t\t\tdelete slots[k as string];\n\t\t}\n\t}\n\tfor (const k of Reflect.ownKeys(children) as string[]) {\n\t\tslots[k] = createSlots(k, children[k]);\n\t}\n\treturn slots;\n}\n","import { isValue } from '../auxiliary';\n\nexport function updateProps(\n\tobj: any,\n\tprops: any,\n\toldProps: any = {},\n\tdefine = false,\n) {\n\tconst newKeys = new Set(Reflect.ownKeys(props));\n\tfor (const k of Reflect.ownKeys(obj)) {\n\t\tif (!newKeys.has(k)) {\n\t\t\tdelete obj[k];\n\t\t}\n\t}\n\tif (!define) {\n\t\tfor (const k of newKeys) {\n\t\t\tobj[k] = props[k];\n\t\t}\n\t\treturn obj;\n\t}\n\tfor (const k of newKeys) {\n\t\tconst value = props[k];\n\t\tif (k in oldProps && oldProps[k] === value) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (isValue(value)) {\n\t\t\tReflect.defineProperty(obj, k, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget() { return value(); },\n\t\t\t\tset(v) { value(v); }\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tReflect.defineProperty(obj, k, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue,\n\t\t});\n\t}\n\treturn obj;\n}","import {\n\tNeepElement, Exposed, Delivered,\n\tRender, NeepNode, Slots, Context, IRender, Component,\n} from '../type';\nimport { typeSymbol } from '../symbols';\nimport { isProduction } from '../constant';\nimport auxiliary, { isElement, Tags } from '../auxiliary';\nimport { renderSymbol, isElementSymbol } from '../symbols';\nimport { getLabel } from '../helper/label';\nimport Container from './Container';\nimport Entity from './Entity';\nimport { getSlots, setSlots } from './slot';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\n\nfunction execSimple(\n\tnObject: Container | Entity,\n\tdelivered: Delivered,\n\tnode: NeepElement,\n\ttag: Component,\n\tchildren: any[],\n) {\n\tconst { iRender } = nObject.container;\n\tconst slotMap = Object.create(null);\n\tgetSlots(iRender, children, slotMap);\n\tconst slots = setSlots(slotMap);\n\tconst context: Context = initContext({\n\t\tslots,\n\t\tcreated: false,\n\t\tparent: nObject.exposed,\n\t\tdelivered,\n\t\tchildren: new Set<Exposed>(),\n\t\tchildNodes: children,\n\t\trefresh(f) { nObject.refresh(f); }\n\t});\n\tif (!isProduction) { getLabel(); }\n\tconst result = tag({...node.props}, context, auxiliary);\n\tlet label: [string, string] | undefined;\n\tif (!isProduction) { label = getLabel(); }\n\tconst nodes = exec(nObject, delivered, renderNode(\n\t\tiRender,\n\t\tresult,\n\t\tcontext,\n\t\ttag[renderSymbol],\n\t), slots);\n\n\treturn {\n\t\t...node,\n\t\tchildren: Array.isArray(nodes) ? nodes : [nodes],\n\t\tlabel,\n\t} as NeepElement;\n}\n\nfunction execSlot(\n\tnode: NeepElement,\n\tslots: Slots,\n\tchildren: any[],\n\targs: any[] = [{}],\n): NeepElement {\n\tconst slotName = node.props?.name || 'default';\n\tconst slot = slots[slotName];\n\tif (typeof slot === 'function') {\n\t\treturn {\n\t\t\t...node,\n\t\t\t...slot(...args),\n\t\t};\n\t}\n\tconst { render } = node;\n\tconst label: [string, string] | undefined = isProduction\n\t\t? undefined\n\t\t: [`[${ slotName }]`, '#00F'];\n\treturn {\n\t\t...node,\n\t\ttag: Tags.ScopeSlot,\n\t\tlabel,\n\t\tchildren:\n\t\t\ttypeof render !== 'function' ? children : render(...args),\n\t};\n}\n\nfunction exec(\n\tnObject: Container | Entity,\n\tdelivered: Delivered,\n\tnode: any,\n\tslots: Slots,\n\tnative = false,\n): any {\n\tif (Array.isArray(node)) {\n\t\treturn node.map(n =>\n\t\t\texec(nObject, delivered, n, slots, native)\n\t\t);\n\t}\n\tif (!isElement(node)) { return node; }\n\tlet { tag, inserted, args = [{}] } = node;\n\tif (tag === Tags.Deliver) {\n\t\tconst props = { ...node.props };\n\t\tdelete props.ref;\n\t\tdelete props.slot;\n\t\tdelete props.key;\n\t\tconst newDelivered = Object.create(delivered);\n\t\tupdateProps(newDelivered, props || {}, {}, true);\n\t\treturn {\n\t\t\t...node,\n\t\t\ttag,\n\t\t\t$__neep__delivered: newDelivered,\n\t\t\tchildren: node.children.map(n => exec(\n\t\t\t\tnObject,\n\t\t\t\tnewDelivered,\n\t\t\t\tn,\n\t\t\t\tslots,\n\t\t\t\tnative,\n\t\t\t)),\n\t\t};\n\t}\n\n\tconst children = node.children\n\t\t.map(n => exec(nObject, delivered, n, slots, native));\n\n\tif (typeof tag === 'function') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn execSimple(nObject, delivered, node, tag, children);\n\t\t}\n\t\treturn { ...node, $__neep__delivered: delivered, children, tag };\n\n\t}\n\tif (tag === Tags.Slot) {\n\t\ttag = native ? 'slot' : Tags.ScopeSlot;\n\t}\n\tif (tag !== Tags.ScopeSlot || inserted) {\n\t\treturn { ...node, children, tag };\n\t}\n\treturn execSlot(node, slots, children, args);\n}\n\n\n\nfunction renderNode<R extends object = object>(\n\tiRender: IRender,\n\tnode: R | NeepNode | NeepNode[] | undefined | null,\n\tcontext: Context,\n\trender?: Render,\n): NeepNode[] {\n\tif (Array.isArray(node)) { return node; }\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\tif (!iRender.isNode(node) && typeof node === 'object' && render) {\n\t\tnode = render(node, context, auxiliary);\n\t}\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\treturn [{\n\t\t[isElementSymbol]: true,\n\t\ttag: Tags.Value,\n\t\tvalue: node,\n\t\tchildren: [],\n\t}];\n}\n\n\nexport default function normalize(\n\tnObject: Entity,\n\tresult: any,\n) {\n\treturn exec(\n\t\tnObject,\n\t\tnObject.delivered,\n\t\trenderNode(\n\t\t\tnObject.iRender,\n\t\t\tresult,\n\t\t\tnObject.context,\n\t\t\tnObject.component[renderSymbol],\n\t\t),\n\t\tnObject.context.slots,\n\t\tBoolean(nObject.native),\n\t);\n}\n","import {\n\tExposed, Delivered,\n\tEntity as ComponentEntity,\n\tNativeComponent,\n\tHook, Hooks, NeepNode, IRender,\n} from '../type';\nimport { callHook, setHook } from '../hook';\nimport { MountedNode } from './draw';\nimport Container from './Container';\nimport convert, { TreeNode } from './convert';\n\nfunction createExposed(obj: NeepObject): Exposed {\n\tconst cfg: { [K in Exclude<keyof Exposed, '$label'>]-?:\n\t\t{ configurable: true, value: Exposed[K] }\n\t\t| { configurable: true, get(): Exposed[K] }\n\t} = {\n\t\t$parent: { configurable: true, get: () => obj.parent?.exposed },\n\t\t$component: { configurable: true, value: null },\n\t\t$isContainer: { configurable: true, value: false },\n\t\t$created: { configurable: true, get: () => obj.created },\n\t\t$destroyed: { configurable: true, get: () => obj.destroyed },\n\t\t$mounted: { configurable: true, get: () => obj.mounted },\n\t\t$unmounted: { configurable: true, get: () => obj.unmounted },\n\t};\n\tconst exposed: Exposed = Object.create(null, cfg);\n\treturn exposed;\n}\n\nfunction createEntity(obj: NeepObject): ComponentEntity {\n\tconst cfg: { [K in keyof ComponentEntity]-?:\n\t\t{ configurable: true, value: ComponentEntity[K] }\n\t\t| { configurable: true, get(): ComponentEntity[K] }\n\t} = {\n\t\texposed: { configurable: true, get: () => obj.exposed },\n\t\tdelivered: { configurable: true, get: () => obj.delivered },\n\t\tparent: { configurable: true, get: () => obj.parent?.entity },\n\t\tcomponent: { configurable: true, value: null },\n\t\tisContainer: { configurable: true, value: false },\n\t\tcreated: { configurable: true, get: () => obj.created },\n\t\tdestroyed: { configurable: true, get: () => obj.destroyed },\n\t\tmounted: { configurable: true, get: () => obj.mounted },\n\t\tunmounted: { configurable: true, get: () => obj.unmounted },\n\t\t$_hooks: { configurable: true, value: Object.create(null) },\n\t\tcallHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(h: string) { callHook(h, entity); },\n\t\t},\n\t\tsetHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(id: string, hook: Hook) {\n\t\t\t\treturn setHook(id, hook, entity);\n\t\t\t},\n\t\t},\n\t\trefresh: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(f?:() => void) { obj.refresh(f); },\n\t\t},\n\t};\n\tconst entity: ComponentEntity = Object.create(null, cfg);\n\treturn entity;\n}\n\nexport default class NeepObject {\n\treadonly iRender: IRender;\n\t/** TODO: 向后代呈递的值 */\n\treadonly parentDelivered: Delivered;\n\t/** TODO: 向后代呈递的值 */\n\treadonly delivered: Delivered;\n\t/** 组件暴露值 */\n\treadonly exposed: Exposed = createExposed(this);\n\t/** 组件实体 */\n\treadonly entity: ComponentEntity = createEntity(this);\n\t/** 父组件 */\n\tparent?: NeepObject;\n\t/** 原生组件 */\n\tnative: NativeComponent | null = null;\n\t/** 状态 */\n\tcreated: boolean = false;\n\tdestroyed: boolean = false;\n\tmounted: boolean = false;\n\tunmounted: boolean = false;\n\t/**  子组件的暴露值 */\n\treadonly children: Set<Exposed> = new Set();\n\t/** The subtree mounted on the parent node */\n\ttree: (MountedNode | MountedNode[])[] = [];\n\treadonly container: Container;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tparent?: NeepObject,\n\t\tdelivered: Delivered = parent?.delivered || Object.create(null),\n\t\tcontainer?: Container,\n\t) {\n\t\tthis.iRender = iRender;\n\t\tthis.parentDelivered = delivered;\n\t\tthis.delivered = Object.create(delivered);\n\t\tif (parent) {\n\t\t\tthis.parent = parent;\n\t\t}\n\t\tthis.container = container || this as any as Container;\n\t}\n\t/** 结果渲染函数 */\n\tprotected _render: () => NeepNode[] = () => [];\n\n\tget canRefresh(): boolean {\n\t\treturn !this._delayedRefresh;\n\t}\n\tprotected get needRefresh(): boolean {\n\t\tif (this._delayedRefresh) { return false; }\n\t\tconst needRefresh = this._needRefresh;\n\t\tthis._needRefresh = false;\n\t\treturn needRefresh;\n\t}\n\t/** 是否需要继续刷新 */\n\tprotected _needRefresh = false;\n\tprivate _delayedRefresh = 0;\n\t/** 是否为刷新中 */\n\tprivate _refreshing = false;\n\t/** 渲染结果 */\n\tprotected _nodes: (TreeNode | TreeNode[])[] = [];\n\tprotected _refresh() { }\n\trefresh(f?: () => void) {\n\t\tif (typeof f === 'function') {\n\t\t\ttry {\n\t\t\t\tthis._delayedRefresh++;\n\t\t\t\tf();\n\t\t\t} finally {\n\t\t\t\tthis._delayedRefresh--;\n\t\t\t\tif (this._delayedRefresh <= 0) {\n\t\t\t\t\tthis.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this.destroyed) { return; }\n\t\tif (!this.created) { return; }\n\t\tthis._needRefresh = true;\n\n\t\tif (this._refreshing) { return; }\n\t\tthis._refreshing = true;\n\n\t\tlet nodes: NeepNode[] | undefined;\n\t\twhile(this.needRefresh) {\n\t\t\tnodes = this._render();\n\t\t\tif (this.destroyed) { return; }\n\t\t}\n\t\tthis._refreshing = false;\n\t\tif (!this.canRefresh) { return; }\n\t\tif (!nodes) { return; }\n\n\t\tthis._nodes = convert(this, nodes, this._nodes);\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tif (this.unmounted) { return; }\n\t\tthis._refresh();\n\t}\n\tcallHook<H extends Hooks>(id: H): void;\n\tcallHook(id: string): void;\n\tcallHook(id: string): void {\n\t\tcallHook(id, this.entity);\n\t}\n\n\tchildNodes: any[] = [];\n\t/** 更新属性及子代 */\n\tprotected _update(props: object, children: any[]): void {\n\t\tthis.childNodes = children;\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: object, children: any[]): void {\n\t\tthis._update(props, children);\n\t}\n\n\n\tprivate __executed_destroy = false;\n\tprivate __executed_mount = false;\n\tprivate __executed_mounted = false;\n\tprotected _destroy() { }\n\tdestroy() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis.__executed_destroy = true;\n\t\tthis.callHook('beforeDestroy');\n\t\tthis._destroy();\n\t\tthis.callHook('destroyed');\n\t\tthis.destroyed = true;\n\t}\n\tprotected _mount() { }\n\tmount() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tif (this.__executed_mount) { return; }\n\t\tthis.__executed_mount = true;\n\t\tthis.callHook('beforeMount');\n\t\tthis._mount();\n\t\tthis.callHook('mounted');\n\t\tthis.mounted = true;\n\t}\n\tprotected _unmount() { }\n\tunmount() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.__executed_mounted) { return; }\n\t\tthis.__executed_mounted = true;\n\t\tthis.callHook('beforeUnmount');\n\t\tthis._unmount();\n\t\tthis.callHook('unmounted');\n\t\tthis.unmounted = true;\n\t}\n\t_draw() {}\n\tdraw() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis.callHook('beforeUpdate');\n\t\tthis._draw();\n\t\tthis.callHook('updated');\n\t}\n}\n","import { Component, NeepNode, Slots, Context, Delivered } from '../type';\nimport auxiliary from '../auxiliary';\nimport { monitorable } from '../install';\nimport { setCurrent } from '../helper/current';\nimport convert, { destroy, TreeNode } from './convert';\nimport draw, { unmount, MountedNode } from './draw';\nimport normalize from './normalize';\nimport { getSlots, setSlots } from './slot';\nimport NeepObject from './Object';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\n\nfunction update(\n\tnObject: Entity<any, any>,\n\tprops: any,\n\tchildren:any[],\n) {\n\tupdateProps(nObject.props, props);\n\n\tconst slots = Object.create(null);\n\tconst {\n\t\tnative,\n\t\tcontainer: { iRender },\n\t} = nObject;\n\tconst childNodes = getSlots(\n\t\tiRender,\n\t\tchildren,\n\t\tslots,\n\t\tBoolean(native),\n\t);\n\tsetSlots(slots, nObject.slots);\n\tif (!native) { return; }\n\tnObject.nativeNodes\n\t\t= convert(nObject, childNodes, nObject.nativeNodes);\n}\n\nfunction createContext<\n\tP extends object = object,\n\tR extends object = object\n>(nObject: Entity<P, R>): Context {\n\treturn initContext({\n\t\tslots: nObject.slots,\n\t\tget created() { return nObject.created; },\n\t\tget parent() { return nObject.parent.exposed; },\n\t\tget delivered() { return nObject.parentDelivered; },\n\t\tget children() { return nObject.children; },\n\t\tget childNodes() { return nObject.childNodes; },\n\t\trefresh(f) { nObject.refresh(f); }\n\t}, nObject.exposed);\n}\n\n/** 初始化渲染 */\nfunction initRender<R extends object = object>(\n\tnObject: Entity<any, R>\n): { render(): any, nodes: any, stopRender(): void } {\n\tconst {\n\t\tcomponent,\n\t\tprops,\n\t\tcontext,\n\t\tentity,\n\t} = nObject;\n\tconst refresh = (changed: boolean) => changed && nObject.refresh()\n\t// 初始化执行\n\tconst result = monitorable.exec(() => setCurrent(\n\t\t() => component(props, context, auxiliary),\n\t\tentity,\n\t), refresh, true);\n\tif (typeof result === 'function') {\n\t\t// 响应式\n\t\tconst render = monitorable.createExecutable(\n\t\t\t() => normalize(nObject, (result as () => NeepNode)()),\n\t\t\trefresh,\n\t\t);\n\t\treturn {\n\t\t\tnodes: render(),\n\t\t\trender,\n\t\t\tstopRender: () => render.stop(),\n\t\t};\n\t}\n\n\tconst render = monitorable.createExecutable(\n\t\t() => normalize(nObject, setCurrent(\n\t\t\t() => component(props, context, auxiliary),\n\t\t\tentity,\n\t\t)),\n\t\trefresh,\n\t);\n\treturn {\n\t\tnodes: monitorable.exec(\n\t\t\t() => normalize(nObject, result), refresh, true,\n\t\t),\n\t\trender,\n\t\tstopRender: () => render.stop(),\n\t};\n}\n\n\nexport default class Entity<\n\tP extends object = object,\n\tR extends object = object\n> extends NeepObject {\n\t/** 组件函数 */\n\treadonly component: Component<P, R>;\n\t/** 组件属性 */\n\treadonly props: P = monitorable.encase(Object.create(null));\n\t/** 组件槽 */\n\treadonly slots: Slots = monitorable.encase(Object.create(null));\n\t/** 结果渲染函数 */\n\tprivate readonly _stopRender:() => void;\n\t/** 原生子代 */\n\tnativeNodes: (TreeNode | TreeNode[])[] | undefined;\n\tnativeTree: (MountedNode | MountedNode[])[] = [];\n\t/** 组件上下文 */\n\treadonly context: Context;\n\treadonly parent: NeepObject;\n\t/** 结果渲染函数 */\n\tconstructor(\n\t\tcomponent: Component<P, R>,\n\t\tprops: object,\n\t\tchildren: any[],\n\t\tparent: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(parent.iRender, parent, delivered, parent.container);\n\t\tthis.component = component;\n\t\tReflect.defineProperty(\n\t\t\tthis.exposed,\n\t\t\t'$component',\n\t\t\t{ value: component, enumerable: true, configurable: true },\n\t\t);\n\t\t// // 原生组件\n\t\t// const native = nativeRender.component\n\t\t// \t&& component[typeSymbol] === 'native' && false;\n\t\t// // 原生组件\n\t\t// const nativeComponent = native\n\t\t// \t? nativeRender.component!()\n\t\t// \t: null;\n\t\t// this.native = nativeComponent;\n\t\t// 父子关系\n\t\tthis.parent = parent;\n\t\tparent.children.add(this.exposed);\n\t\t// 上下文属性\n\t\tconst context = createContext(this);\n\t\tthis.context = context;\n\t\t// 初始化钩子\n\t\tthis.callHook('beforeCreate');\n\t\t// 更新属性\n\t\tthis.childNodes = children;\n\t\tupdate(this, props, children);\n\t\t// 获取渲染函数及初始渲染\n\t\tconst { render, nodes, stopRender } = initRender(this);\n\t\tthis._render = render;\n\t\tthis._stopRender = stopRender;\n\t\tthis._nodes = convert(this, nodes);\n\t\t// 初始化钩子\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t\tif (this._needRefresh) { this.refresh(); }\n\t}\n\t/** 更新属性及子代 */\n\t_update(props: object, children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\tupdate(this, props, children);\n\t}\n\t_destroy() {\n\t\tif (this._stopRender) {\n\t\t\tthis._stopRender();\n\t\t}\n\t\tthis.parent.children.delete(this.exposed);\n\t\tdestroy(this._nodes);\n\t}\n\n\t/** 刷新 */\n\t_refresh() {\n\t\tthis.container.markDraw(this);\n\t}\n\t_draw() {\n\t\tthis.tree = draw(\n\t\t\tthis.container.iRender,\n\t\t\tthis._nodes,\n\t\t\tthis.tree,\n\t\t);\n\t\tconst {native} = this;\n\t\tif (native) {\n\t\t\t// const shadow = this.container.iRender.shadow!(native);\n\t\t\t// TODO: 更新 childNodes\n\t\t}\n\t}\n\t_mount() {\n\t\tthis.tree = draw(this.container.iRender, this._nodes);\n\t}\n\t_unmount() {\n\t\tunmount(this.container.iRender, this.tree);\n\t}\n}\n","import { getRender } from '../install';\nimport { NeepNode, NeepElement, Tag } from '../type';\nimport { Tags, isElement, Value, Template } from '../auxiliary';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport { recursive2iterable } from './recursive';\nimport Entity from './Entity';\nimport NeepObject from './Object';\nimport Container from './Container';\nimport { updateProps } from './props';\n\nexport interface TreeNode\n\textends Omit<\n\t\tNeepElement,\n\t\t'children' | 'tag' | typeof isElementSymbol\n\t>\n{\n\t/** 标签名 */\n\ttag: Tag;\n\tchildren: (this | this[])[];\n\tmounted?: boolean;\n\tcomponent?: NeepObject;\n}\n/** 强制转换为 NeepElement */\nfunction toElement(t: any): null | NeepElement {\n\tif (t === false || t === null || t === undefined) {\n\t\treturn null;\n\t}\n\tif (isElement(t)) {\n\t\treturn t;\n\t}\n\treturn {\n\t\t[isElementSymbol]: true,\n\t\ttag: Value,\n\t\tkey: t,\n\t\tvalue: t,\n\t\tchildren: [],\n\t};\n}\n\nexport function destroy(\n\ttree: TreeNode | TreeNode[] | (TreeNode | TreeNode[])[]\n) {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(t => destroy(t));\n\t\treturn;\n\t}\n\tconst { component } = tree;\n\tif (component) { component.destroy(); }\n}\n\nfunction createItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n): TreeNode {\n\tif (!source) { return { tag: null, children: [] }; }\n\tconst { tag } = source;\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(nObject, source.children),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Entity(\n\t\t\t\ttag,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Container(\n\t\t\t\tiRender,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\treturn {\n\t\t\t...source,\n\t\t\tchildren: convert(nObject, source.children),\n\t\t};\n\t}\n\treturn {...source, children: convert(nObject, source.children) };\n}\n\n/**\n * 更新树节点\n * @param nObject Neep 对象\n * @param source 用于替换的源\n * @param tree 已有树\n */\nfunction updateList(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: TreeNode | TreeNode[],\n): TreeNode[] {\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: TreeNode[] = [];\n\tfor (const src of recursive2iterable(source)) {\n\t\tconst node = toElement(src);\n\t\tif (!node) { continue; }\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === node.tag && it.key === node.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tnewList.push(updateItem(nObject, node, tree[index]));\n\t\t\ttree.splice(index, 1);\n\t\t} else {\n\t\t\tnewList.push(createItem(nObject, node));\n\t\t}\n\t}\n\tdestroy(tree);\n\treturn newList;\n}\n\n/**\n * 更新树节点\n * @param tree 已有树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n */\nfunction updateItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n\ttree?: TreeNode | TreeNode[],\n): TreeNode {\n\tif (!tree) {\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!source) {\n\t\tdestroy(tree);\n\t\treturn { tag: null, children: [] };\n\t}\n\tif (Array.isArray(tree)) {\n\t\tif (!tree.length) { return createItem(nObject, source); }\n\t\tconst index = tree.findIndex(it => it.tag === source.tag);\n\t\tif (index < 0) {\n\t\t\tdestroy(tree);\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tdestroy(all);\n\t}\n\tconst { tag } = source;\n\tif (tag !== tree.tag) {\n\t\tdestroy(tree);\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(\n\t\t\t\t\tnObject,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tcomponent!.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\tif (iRender !== component.iRender) {\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tcomponent!.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\tlet delivered: any;\n\t\tif (Tags.Deliver === tag) {\n\t\t\tconst props = { ...source.props };\n\t\t\tdelete props.ref;\n\t\t\tdelete props.slot;\n\t\t\tdelete props.key;\n\t\t\tdelivered = updateProps(\n\t\t\t\ttree.$__neep__delivered,\n\t\t\t\tprops,\n\t\t\t\ttree.props,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t\treturn {\n\t\t\t...source,\n\t\t\t$__neep__delivered: delivered,\n\t\t\tchildren: convert(\n\t\t\t\tnObject,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t};\n\t}\n\treturn {\n\t\t...source,\n\t\tchildren: convert(nObject, source.children, tree.children),\n\t};\n}\n\n\nfunction createAll(\n\tnObject: NeepObject,\n\tsource: any[],\n): (TreeNode | TreeNode[])[] {\n\tif (!source.length) { return []; }\n\treturn (source as any[]).map(item => {\n\t\tif (!Array.isArray(item)) {\n\t\t\treturn createItem(nObject, toElement(item));\n\t\t}\n\t\treturn [...recursive2iterable(item)]\n\t\t\t.map(it => createItem(nObject, toElement(it)));\n\t});\n}\nfunction *updateAll(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: (TreeNode | TreeNode[])[],\n): Iterable<TreeNode | TreeNode[]> {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length);\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tyield updateList(nObject, src, tree[index]);\n\t\t} else {\n\t\t\tyield updateItem(nObject, toElement(src), tree[index]);\n\t\t}\n\t}\n\tlength = Math.max(source.length, source.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tdestroy(tree[index]);\n\t\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = source[index];\n\t\t\tif (Array.isArray(src)) {\n\t\t\t\tyield [...recursive2iterable(src)]\n\t\t\t\t\t.map(it => createItem(nObject, it));\n\t\t\t} else {\n\t\t\t\tyield createItem(nObject, src);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * 更新树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n * @param tree 已有树\n */\nfunction convert(\n\tnObject: NeepObject,\n\tsource: any,\n\ttree?: (TreeNode | TreeNode[])[],\n): (TreeNode | TreeNode[])[] {\n\tif (!Array.isArray(source)) { source = []; }\n\tif (!tree) {\n\t\treturn createAll(nObject, source);\n\t}\n\treturn [...updateAll(nObject, source, tree)];\n}\n\n\nexport default convert;\n","import {\n\tIRender,\n\tMountProps,\n\tNativeNode,\n\tNativeContainer,\n\tDelivered,\n} from '../type';\nimport { Tags } from '../auxiliary';\nimport { createMountedNode } from './id';\nimport convert, { destroy } from './convert';\nimport draw, { unmount, getNodes, MountedNode } from './draw';\nimport NeepObject from './Object';\n\n\nlet awaitDraw = new Set<Container>();\nlet requested = false;\nfunction markDraw(c: Container) {\n\tawaitDraw.add(c);\n\tif (requested) { return; }\n\trequested = true;\n\twindow.requestAnimationFrame(() => {\n\t\trequested = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tlist.map(c => c.drawAll());\n\t});\n}\n\nexport default class Container extends NeepObject {\n\tprops: MountProps;\n\t/** 组件树结构 */\n\tcontent: (MountedNode | MountedNode[])[] = [];\n\t_node: NativeNode | null = null;\n\t_container: NativeContainer | null = null;\n\treadonly rootContainer: Container = this;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tprops: MountProps,\n\t\tchildren: any[],\n\t\tparent?: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(iRender, parent, delivered);\n\t\tthis.props = props;\n\t\tthis.parent = parent;\n\t\tif (parent) {\n\t\t\tthis.rootContainer = parent.container.rootContainer;\n\t\t}\n\t\tthis.callHook('beforeCreate');\n\t\tthis._render = () => children;\n\t\tthis._nodes = convert(this, children);\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t}\n\t_drawChildren = false;\n\t_drawContainer = false;\n\tsetChildren(children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\tthis._render = () => children;\n\t\tthis._drawChildren = true;\n\t\tthis.refresh();\n\t}\n\tsetProps(props: MountProps): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.props = props;\n\t\tthis._drawContainer = true;\n\t\tthis.refresh();\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: MountProps, children: any[]): void {\n\t\tthis.refresh(() => {\n\t\t\tthis.setProps(props);\n\t\t\tthis.setChildren(children);\n\t\t});\n\t}\n\t_refresh() {\n\t\tthis.markDraw(this);\n\t}\n\t_mount() {\n\t\tconst { props, parent, iRender } = this;\n\t\tconst content = draw(this.container.iRender, this._nodes);\n\t\tthis.content = content;\n\t\tconst [container, node]\n\t\t\t= iRender.mount(props, parent?.iRender);\n\t\tfor (const it of getNodes(content)) {\n\t\t\tiRender.insert(container, it);\n\t\t}\n\t\tthis.tree = [createMountedNode({\n\t\t\ttag: Tags.Value,\n\t\t\tcomponent: undefined,\n\t\t\tnode,\n\t\t\tvalue: node,\n\t\t\tchildren: [],\n\t\t})];\n\t\tthis._node = node;\n\t\tthis._container = container;\n\t}\n\t_destroy() {\n\t\tdestroy(this.content);\n\t}\n\t_unmount() {\n\t\tconst { parent, iRender } = this;\n\t\tif (parent) {\n\t\t\tunmount(parent.iRender, this.tree);\n\t\t}\n\t\tiRender.unmount(\n\t\t\tthis._container!,\n\t\t\tthis._node!,\n\t\t\tBoolean(parent),\n\t\t);\n\t\tunmount(this.iRender, this.content);\n\t}\n\t_draw() {\n\t}\n\tdrawSelf() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tconst {\n\t\t\t_drawChildren: drawChildren,\n\t\t\t_drawContainer: drawContainer,\n\t\t} = this;\n\t\tthis._needDraw = false;\n\t\tthis._drawChildren = false;\n\t\tthis._drawContainer = false;\n\t\tthis.callHook('beforeUpdate');\n\t\tif (drawContainer) {\n\t\t\tthis.iRender.drawContainer(\n\t\t\t\tthis._container!,\n\t\t\t\tthis._node!,\n\t\t\t\tthis.props,\n\t\t\t\tthis.parent?.iRender,\n\t\t\t);\n\t\t}\n\t\tif (drawChildren) {\n\t\t\tthis.content = draw(\n\t\t\t\tthis.iRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.content,\n\t\t\t);\n\t\t}\n\t\tthis.callHook('updated');\n\t}\n\t/** 等待重画的项目 */\n\tprivate _awaitDraw = new Set<NeepObject>();\n\t/** 自身是否需要重绘 */\n\tprivate _needDraw = false;\n\t/** 标记需要绘制的元素 */\n\tmarkDraw(\n\t\tnObject: NeepObject,\n\t\tremove = false,\n\t) {\n\t\tif (nObject === this) {\n\t\t\tthis._needDraw = !remove;\n\t\t} else if (remove) {\n\t\t\tthis._awaitDraw.delete(nObject);\n\t\t} else {\n\t\t\tthis._awaitDraw.add(nObject);\n\t\t}\n\t\tthis.rootContainer.markDrawContainer(\n\t\t\tthis,\n\t\t\t!this._needDraw && !this._awaitDraw.size || this.destroyed,\n\t\t);\n\t}\n\tdrawContainer() {\n\t\tconst {\n\t\t\t_node: node,\n\t\t\t_container: container,\n\t\t\t_awaitDraw: awaitDraw,\n\t\t} = this;\n\t\tif (!node || !container) { return; }\n\t\tthis.callHook('beforeDraw');\n\t\tconst needDraw = this._needDraw;\n\t\tthis._needDraw = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tif (needDraw) { this.drawSelf(); }\n\t\tlist.map(c => c.draw());\n\t\tthis.iRender.draw(container, node);\n\t\tthis.callHook('drawn');\n\t}\n\tprivate _containers = new Set<Container>();\n\tmarkDrawContainer(\n\t\tcontainer: Container,\n\t\tremove = false,\n\t) {\n\t\tif (remove) {\n\t\t\tthis._containers.delete(container);\n\t\t} else {\n\t\t\tthis._containers.add(container);\n\t\t}\n\t\tmarkDraw(this);\n\t}\n\tdrawAll() {\n\t\tconst containers = this._containers;\n\t\tif (!containers.size) { return; }\n\t\tthis.callHook('beforeDrawAll');\n\t\tconst list = [...containers];\n\t\tlist.map(c => c.drawContainer());\n\t\tthis.callHook('drawnAll');\n\t}\n}\n","import { Component, Render, Marks } from './type';\nimport { nameSymbol, typeSymbol, renderSymbol } from './symbols';\n\n/** 组件标记函数 */\nexport interface Mark {\n\t<N extends Component<any, any>>(component: N): N;\n}\n\n/**\n * 创建组件标记函数\n */\nfunction Mark<S extends keyof Marks>(\n\tsymbol: S,\n\tvalue: Component[S],\n): Mark {\n\treturn component => {\n\t\tcomponent[symbol] = value as any;\n\t\treturn component;\n\t};\n}\n\n\n/** 标记组件名称 */\nexport function mName(name: string): Mark;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent: N,\n): N;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(nameSymbol, name); }\n\tcomponent[nameSymbol] = name;\n\treturn component;\n}\n\n/** 标记组件类型 */\nexport function mType(type?: 'native' | 'simple' | 'standard'): Mark;\nexport function mType<N extends Component<any, any>>(\n\ttype: 'native' | 'simple' | 'standard',\n\tcomponent: N,\n): N;\nexport function mType<N extends Component<any, any>>(\n\ttype?: 'native' | 'simple' | 'standard',\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, type); }\n\tcomponent[typeSymbol] = type;\n\treturn component;\n}\n/** 标记为简单组件 */\nexport function mSimple(): Mark;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'simple'); }\n\tcomponent[typeSymbol] = 'simple';\n\treturn component;\n}\n/** 标记为原生组件 */\nexport function mNative(): Mark;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'native'); }\n\tcomponent[typeSymbol] = 'native';\n\treturn component;\n}\n\n/** 标记独立的渲染函数 */\nexport function mRender(fn?: Marks[typeof renderSymbol]): Mark;\nexport function mRender<N extends Component<any, any>>(\n\tfn: Marks[typeof renderSymbol] | undefined,\n\tcomponent: N,\n): N;\nexport function mRender<N extends Component<any, any>>(\n\tfn?: Marks[typeof renderSymbol] | undefined,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(renderSymbol, fn); }\n\tcomponent[renderSymbol] = fn;\n\treturn component;\n}\n\nexport function create<P extends object>(\n\tc: Component<P, never>,\n): Component<P, never>;\nexport function create<\n\tP extends object = object,\n\tR extends object = object,\n>(c: Component<P, R>, r: Render<R>): Component<P, R>;\nexport function create<T extends Component<any, any>>(\n\tc: T,\n\tr?: Render,\n): T {\n\tif (typeof r === 'function') {\n\t\tc[renderSymbol] = r;\n\t}\n\treturn c;\n}\n\nexport function mark<N extends Component<any, any>>(\n\tcomponent: N,\n\t...marks: Mark[]\n): N {\n\tfor (const m of marks) { m(component); }\n\treturn component;\n}\n","import {\n\trecursive2iterable, RecursiveItem,\n} from '../core/render/recursive';\n\nfunction getId(v: any): string | undefined {\n\tif (typeof v === 'string') { return v; }\n\tif (typeof v === 'number') { return String(v); }\n\treturn undefined;\n}\nfunction getClass(\n\tlist: RecursiveItem<(string | {[k: string]: any})>\n): Set<string> | undefined {\n\tconst set = new Set<string>();\n\tfor (const v of recursive2iterable(list)) {\n\t\tif (!v) { continue; }\n\t\tif (typeof v === 'string') {\n\t\t\tfor (let k of v.split(' ').filter(Boolean)) {\n\t\t\t\tset.add(k);\n\t\t\t}\n\t\t} else if (typeof v === 'object') {\n\t\t\tfor (const k in v) {\n\t\t\t\tconst add = v[k];\n\t\t\t\tfor (let it of k.split(' ').filter(Boolean)) {\n\t\t\t\t\tset[add ? 'add' : 'delete'](it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!set.size) { return undefined; }\n\treturn set;\n}\n\nfunction getStyle(\n\tstyle: any\n): string | Record<string, [string, 'important' | null]> | undefined {\n\tif (typeof style === 'string') { return style; }\n\tif (!style) { return undefined; }\n\tif (typeof style !== 'object') { return undefined; }\n\tconst css: Record<string, [string, 'important' | null]> =\n\t\tObject.create(null);\n\tfor (let k in style) {\n\t\tlet value = style[k];\n\t\tconst key = k.substr(0, 2) === '--' ? k\n\t\t\t: k.replace(/[A-Z]/g, '-$1')\n\t\t\t\t.replace(/-+/g, '-')\n\t\t\t\t.toLowerCase();\n\t\tif (typeof value === 'number') {\n\t\t\tcss[key] = [value === 0 ? '0' : `${value}px`, null];\n\t\t} else if (value && typeof value === 'string') {\n\t\t\tconst v = value.replace(/\\!important\\s*$/, '');\n\t\t\tcss[key] = [v, v === value ? null : 'important'];\n\t\t}\n\t}\n\treturn css;\n}\n\nfunction stringify(data: any, isOn = false): string | null {\n\tif (data === undefined || data === null) { return null; }\n\tif (isOn && typeof data === 'function') { return null; }\n\tif (typeof data === 'boolean') { return data ? '' : null; }\n\tif (typeof data !== 'object') { return String(data); }\n\tif (data instanceof Date) {\n\t\treturn data.toISOString();\n\t}\n\tif (data instanceof RegExp) {\n\t\treturn data.toString();\n\t}\n\treturn JSON.stringify(data);\n}\nfunction getAttrs(props: {[k: string]: any}) {\n\tconst attrs: Record<string, string> = Object.create(null);\n\tfor (const k in props) {\n\t\tconst name = k\n\t\t\t.replace(/([A-Z])/g, '-$1')\n\t\t\t.replace(/(\\-)\\-+/g, '$1')\n\t\t\t.toLowerCase();\n\t\tswitch(name) {\n\t\t\tcase 'is': continue;\n\t\t\tcase 'id': continue;\n\t\t\tcase 'style': continue;\n\t\t\tcase 'class': continue;\n\t\t}\n\t\tconst value = stringify(props[k], name.substr(0, 2) === 'on');\n\t\tif (value !== null) { attrs[name] = value; }\n\t}\n\treturn attrs;\n}\nfunction getEvent(props: {[k: string]: any}) {\n\tconst evt: Record<string, Set<EventListener>> = Object.create(null);\n\tfor (const k in props) {\n\t\tconst f = props[k];\n\t\tif (typeof f !== 'function') { continue; }\n\t\tif (k.substr(0, 2) !== 'on') { continue; }\n\t\tevt[k.substr(2).toLowerCase()] = new Set([f]);\n\t}\n\treturn evt;\n}\ninterface Props {\n\tid?: string;\n\tclasses?: Set<string>;\n\tstyle?: string | Record<string, [string, 'important' | null]>;\n\tattrs: Record<string, string>;\n\tevent: Record<string, Set<EventListener>>;\n}\nfunction getProps({\n\tid,\n\tclass: className,\n\tstyle,\n\t...attrs\n}: {[k: string]: any}): Props {\n\treturn {\n\t\tid: getId(id),\n\t\tclasses: getClass(className),\n\t\tstyle: getStyle(style),\n\t\tattrs: getAttrs(attrs),\n\t\tevent: getEvent(attrs),\n\t};\n}\n\nfunction updateClass(\n\tel: HTMLElement | SVGElement,\n\tclasses?: Set<string>,\n\toClasses?: Set<string>,\n) {\n\tif (classes && oClasses) {\n\t\tconst list = el.getAttribute('class') || '';\n\t\tconst classList = new Set(list.split(' ').filter(Boolean));\n\t\toClasses.forEach(c => classList.delete(c));\n\t\tclasses.forEach(c => classList.add(c));\n\t\tel.setAttribute('class', [...classList].join(' '));\n\t} else if (classes) {\n\t\tel.setAttribute('class', [...classes].join(' '));\n\t} else if (oClasses) {\n\t\tel.removeAttribute('class');\n\t}\n}\nfunction updateStyle(\n\tcss: CSSStyleDeclaration,\n\tstyle?: string | Record<string, [string, 'important' | null]>,\n\toStyle?: string | Record<string, [string, 'important' | null]>,\n) {\n\tif (!style) {\n\t\tif (!oStyle) { return; }\n\t\tif (typeof oStyle === 'string') {\n\t\t\tcss.cssText = '';\n\t\t\treturn;\n\t\t}\n\t\tfor (const k of Object.keys(oStyle)) {\n\t\t\tcss.removeProperty(k);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (typeof style === 'string') {\n\t\tif (style !== typeof oStyle) {\n\t\t\tcss.cssText = style;\n\t\t}\n\t\treturn;\n\t}\n\tif (!oStyle || typeof oStyle === 'string') {\n\t\tif (typeof oStyle === 'string') {\n\t\t\tcss.cssText = '';\n\t\t}\n\t\tfor (const k of Object.keys(style)) {\n\t\t\tcss.setProperty(k, ...style[k]);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (const k of Object.keys(style)) {\n\t\tconst v = style[k];\n\t\tif (\n\t\t\t!oStyle[k]\n\t\t\t|| oStyle[k][0] !== v[0]\n\t\t\t|| oStyle[k][1] !== v[1]\n\t\t) {\n\t\t\tcss.setProperty(k, ...v);\n\t\t}\n\t}\n\tfor (const k of Object.keys(oStyle)) {\n\t\tif (!style[k]) {\n\t\t\tcss.removeProperty(k);\n\t\t}\n\t}\n}\nfunction updateAttrs(\n\tel: HTMLElement | SVGElement,\n\tattrs: Record<string, string>,\n\toAttrs: Record<string, string>,\n) {\n\tfor (const k of Object.keys(attrs)) {\n\t\tconst v = attrs[k];\n\t\tif (!(k in oAttrs) || oAttrs[k] !== v) {\n\t\t\tel.setAttribute(k, v);\n\t\t}\n\t}\n\tfor (const k of Object.keys(oAttrs)) {\n\t\tif (!(k in attrs)) {\n\t\t\tel.removeAttribute(k);\n\t\t}\n\t}\n}\n\nfunction updateEvent(\n\tel: HTMLElement | SVGElement,\n\tevt: Record<string, Set<EventListener>>,\n\toEvt: Record<string, Set<EventListener>>,\n) {\n\n\tfor (const k of Object.keys(evt)) {\n\t\tconst set = evt[k];\n\t\tif (k in oEvt) {\n\t\t\tconst oSet = oEvt[k];\n\t\t\tfor (const f of set) {\n\t\t\t\tif (!oSet.has(f)) { el.addEventListener(k, f); }\n\t\t\t}\n\t\t\tfor (const f of oSet) {\n\t\t\t\tif (!set.has(f)) { el.removeEventListener(k, f); }\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const f of set) {\n\t\t\t\tel.addEventListener(k, f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (const k of Object.keys(oEvt)) {\n\t\tif (k in evt) { continue; }\n\t\tfor (const f of oEvt[k]) {\n\t\t\tel.removeEventListener(k, f);\n\t\t}\n\t}\n}\n\nconst PropsMap = new WeakMap<Element, Props>();\nexport default function update(\n\tel: HTMLElement | SVGElement,\n\tprops: {[k: string]: any},\n) {\n\tconst old = PropsMap.get(el) || { attrs: {}, event: {} };\n\tconst { id,  classes, style, attrs, event } = getProps(props);\n\tPropsMap.set(el, { id, classes, style, attrs, event });\n\tif (id !== old.id) {\n\t\tif (typeof id === 'string') {\n\t\t\tel.id = props.id;\n\t\t} else {\n\t\t\tel.removeAttribute('id');\n\t\t}\n\t}\n\tupdateClass(el, classes, old.classes);\n\tupdateStyle(el.style, style, old.style);\n\tupdateAttrs(el, attrs, old.attrs);\n\tupdateEvent(el, event, old.event);\n\treturn el;\n}\n","\nimport update from './update';\nimport {\n\tIRender,\n\tNativeNode,\n\tNativeText,\n\tNativePlaceholder,\n\tNativeComponent,\n\tNativeShadow,\n\tNativeContainer,\n\tNativeElement,\n} from '@neep/core';\n\nconst render: IRender = {\n\ttype: 'html',\n\tisNode(v): v is NativeNode {\n\t\treturn v instanceof Node;\n\t},\n\tmount({target, class: className, style, tag}, parent) {\n\t\tif (!(\n\t\t\ttypeof tag === 'string' &&\n\t\t\t/^[a-z][a-z0-9]*(?:\\-[a-z0-9]+)?(?:\\:[a-z0-9]+(?:\\-[a-z0-9]+)?)?$/i.test(tag)\n\t\t)) {\n\t\t\ttag = 'div';\n\t\t}\n\t\tconst container = render.create(tag, { class: className, style });\n\t\tif (typeof target === 'string') {\n\t\t\ttarget = document.querySelector(target);\n\t\t}\n\t\tif (target instanceof Element) {\n\t\t\ttarget.appendChild(container as any);\n\t\t\tif (parent) {\n\t\t\t\treturn [container, parent.placeholder] as any;\n\t\t\t}\n\t\t\treturn [container, container];\n\t\t}\n\t\tif (parent !== render) {\n\t\t\tdocument.body.appendChild(container as any);\n\t\t\treturn [container, container] as any;\n\t\t}\n\t\treturn [container, container] as any;\n\t},\n\tunmount(container, node, removed) {\n\t\tif (container === node && removed) { return; }\n\t\t(container as any as Element).remove();\n\t},\n\tdrawContainer(container, node, {target, class: className, style, tag}, parent) {\n\t\trender.update(container as NativeElement, { class: className, style })\n\t\tif (typeof target === 'string') {\n\t\t\ttarget = document.querySelector(target);\n\t\t}\n\t\tif (parent !== render && !(target instanceof Element)) {\n\t\t\ttarget = document.body;\n\t\t}\n\t\tconst oldTarget = parent === render && container === node ? undefined : render.parent(node);\n\t\tif (oldTarget === target) {\n\t\t\treturn [container, node];\n\t\t}\n\t\tif (parent !== render) {\n\t\t\ttarget.appendChild(container);\n\t\t\treturn [container, node];\n\t\t}\n\t\tif (!oldTarget) {\n\t\t\tconst newNode = parent.placeholder();\n\t\t\tconst pNode = parent.parent(node);\n\t\t\tif (pNode) {\n\t\t\t\trender.insert(pNode, newNode as any, node);\n\t\t\t\trender.remove(node);\n\t\t\t}\n\t\t\treturn [container, newNode];\n\t\t}\n\t\tif (!target) {\n\t\t\tconst pNode = parent.parent(node);\n\t\t\tif (pNode) {\n\t\t\t\trender.insert(pNode, container, node);\n\t\t\t\trender.remove(node);\n\t\t\t}\n\t\t\treturn [container, container];\n\n\t\t}\n\t\ttarget.appendChild(node);\n\t\treturn [container, node];\n\t},\n\tdraw() {},\n\n\tcreate(tag, props) {\n\t\t// TODO: NS\n\t\t// 你好啊\n\t\treturn update(document.createElement(tag), props) as any;\n\t},\n\ttext(text: string): NativeText {\n\t\treturn document.createTextNode(text) as any;\n\t},\n\tplaceholder(): NativePlaceholder {\n\t\treturn document.createComment('') as any;\n\t},\n\tcomponent(): [NativeComponent, NativeShadow] {\n\t\tconst node = document.createElement('neep-component');\n\t\tnode.attachShadow({ mode: 'open' });\n\t\treturn [node, node.attachShadow({ mode: 'open' })] as any;\n\t},\n\n\tparent(node: NativeNode): NativeContainer | null {\n\t\treturn (node as any).parentNode as NativeContainer | null;\n\t},\n\tnext(node: NativeNode): NativeNode | null {\n\t\treturn (node as any).nextSibling as NativeContainer | null;\n\t},\n\tupdate(node, props): void {\n\t\tupdate(node as any, props);\n\t},\n\tinsert(\n\t\tparent: NativeContainer,\n\t\tnode: NativeNode,\n\t\tnext: NativeNode | null = null,\n\t): void {\n\t\t(parent as any).insertBefore(node, next);\n\t},\n\tremove(node: NativeNode): void {\n\t\tconst p = render.parent(node);\n\t\tif (!p) { return; }\n\t\t(p as any).removeChild(node);\n\t},\n};\n\nexport default render;\n","\n/*!\n * monitorable v0.1.0-alpha.3\n * (c) 2020 Fierflame\n * @license MIT\n */\n\nlet printErrorLog;\n/** 设置或移除错误打印函数 */\n\nfunction printError(info, print = false) {\n  if (!print && (typeof info === 'function' || info === undefined)) {\n    printErrorLog = info;\n    return;\n  }\n\n  if (typeof printErrorLog === 'function') {\n    printErrorLog(info);\n    return;\n  }\n\n  console.error(info);\n}\n/**\n * 判断对象是否可被代理\n */\n\nfunction encashable(v) {\n  return Boolean(v && ['object', 'function'].includes(typeof v));\n}\n/** 回调函数安全化处理 */\n\nfunction safeify(fn) {\n  return (...p) => {\n    try {\n      fn(...p);\n    } catch (e) {\n      printError(e, true);\n    }\n  };\n}\nfunction getMapValue(map, key, def) {\n  if (map.has(key)) {\n    return map.get(key);\n  }\n\n  const value = def();\n  map.set(key, value);\n  return value;\n}\n\n/** 已被读取的 */\nlet read;\n/**\n * 标记已读状态\n * @param obj  要标记的对象\n * @param prop 要标记的属性\n */\n\nfunction markRead(obj, prop) {\n  if (!read) {\n    return;\n  }\n\n  const set = getMapValue(read, obj, () => new Set());\n\n  if (typeof prop === 'number') {\n    prop = String(prop);\n  }\n\n  set.add(prop);\n}\n/**\n * 监听函数的执行，并将执行过程中读取的对象值设置到 map 中\n * @param fn 要执行的含糊\n * @param map 用于存储被读取对象的 map\n * @param clear 是否在发送错误时清空 map\n */\n\nfunction observe(fn, map) {\n  const oldRead = read;\n  read = map;\n\n  try {\n    return fn();\n  } finally {\n    read = oldRead;\n  }\n}\nconst watchList = new WeakMap();\n/**\n * 标记属性的修改，同时触发监听函数\n * @param target 要标记的对象\n * @param prop   要标记的属性 特别的，false 表示原型，true 表示成员\n */\n\nfunction markChange(target, prop) {\n  var _watchList$get, _watchList$get$get;\n\n  if (!target) {\n    return;\n  }\n\n  if (!encashable(target)) {\n    return;\n  }\n\n  if (typeof prop === 'number') {\n    prop = String(prop);\n  } else if (typeof prop !== 'symbol' && typeof prop !== 'string' && typeof prop !== 'boolean') {\n    return;\n  }\n\n  const watch = (_watchList$get = watchList.get(target)) === null || _watchList$get === void 0 ? void 0 : (_watchList$get$get = _watchList$get.get) === null || _watchList$get$get === void 0 ? void 0 : _watchList$get$get.call(_watchList$get, prop);\n\n  if (!watch) {\n    return;\n  }\n\n  for (const w of [...watch]) {\n    w();\n  }\n}\n/**\n * 监听对象属性的变化\n * @param target 要监听的对象\n * @param prop   要监听的属性名 特别的，false 表示原型，true 表示成员\n * @param fn     属性改变后触发的函数\n */\n\nfunction watchProp(target, prop, cb) {\n  if (!target) {\n    return () => {};\n  }\n\n  if (!(typeof target === 'object' || typeof target === 'function')) {\n    return () => {};\n  }\n\n  if (typeof cb !== 'function') {\n    return () => {};\n  }\n\n  if (typeof prop === 'number') {\n    prop = String(prop);\n  }\n\n  if (typeof prop !== 'symbol' && typeof prop !== 'string' && typeof prop !== 'boolean') {\n    return () => {};\n  }\n\n  const key = prop;\n  let map = watchList.get(target);\n\n  if (!map) {\n    map = new Map();\n    watchList.set(target, map);\n  }\n\n  const list = getMapValue(map, key, () => new Set());\n  cb = safeify(cb);\n  list.add(cb);\n  let removed = false;\n  return () => {\n    if (removed) {\n      return;\n    }\n\n    removed = true; // 从当前列表中移除\n\n    list.delete(cb); // 从属性关联中删除\n\n    if (list.size) {\n      return;\n    }\n\n    if (!map) {\n      return;\n    }\n\n    map.delete(key); // 映射列表中删除\n\n    if (map.size) {\n      return;\n    }\n\n    watchList.delete(target);\n  };\n}\n\n/**\n * 判断对象是否可被代理\n */\n\nfunction encashable$1(v) {\n  return Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\nlet getValue;\n/**\n * 获取被代理对象\n * @param obj  要被代理的对象\n * @param nest 递归代理的层数\n */\n\nfunction encase(value, nest = 0) {\n  if (!encashable$1(value)) {\n    return value;\n  }\n\n  const original = recover(value);\n  const nestLayer = nest === true ? Infinity : nest || 0;\n  const proxy = new Proxy(original, {\n    set(target, prop, value, receiver) {\n      if (nest === false) {\n        return Reflect.set(target, prop, value, receiver);\n      }\n\n      const has = Reflect.has(target, prop);\n      const modified = Reflect.set(target, prop, value, encase(receiver));\n\n      if (!modified) {\n        return modified;\n      }\n\n      if (has !== Reflect.has(target, prop)) {\n        markChange(target, true);\n      }\n\n      return modified;\n    },\n\n    get(target, prop, receiver) {\n      if (getValue === proxy) {\n        if (prop === '__monitorable__recover__') {\n          getValue = original;\n          return;\n        }\n      }\n\n      if (nest === false) {\n        return Reflect.get(target, prop, receiver);\n      }\n\n      markRead(target, prop);\n      const value = Reflect.get(target, prop, encase(receiver));\n\n      if (nestLayer > 0) {\n        return encase(value, nestLayer - 1);\n      }\n\n      return value;\n    },\n\n    setPrototypeOf(target, proto) {\n      if (nest === false) {\n        return Reflect.setPrototypeOf(target, proto);\n      }\n\n      const oldProto = Reflect.getPrototypeOf(target);\n      const modified = Reflect.setPrototypeOf(target, proto);\n\n      if (modified && oldProto !== proto) {\n        markChange(target, false);\n      }\n\n      return modified;\n    },\n\n    getPrototypeOf(target) {\n      if (nest === false) {\n        return Reflect.getPrototypeOf(target);\n      }\n\n      markRead(target, false);\n      const value = Reflect.getPrototypeOf(target);\n\n      if (nestLayer > 0) {\n        return encase(value, nestLayer - 1);\n      }\n\n      return value;\n    },\n\n    defineProperty(target, prop, attr) {\n      if (nest === false) {\n        return Reflect.defineProperty(target, prop, attr);\n      }\n\n      let changed = true;\n\n      if ('value' in attr) {\n        const desc = Reflect.getOwnPropertyDescriptor(target, prop);\n\n        if (desc && 'value' in desc && recover(attr.value) === recover(desc.value)) {\n          changed = false;\n        }\n      }\n\n      const modified = Reflect.defineProperty(target, prop, attr);\n\n      if (changed && modified) {\n        markChange(target, prop);\n      }\n\n      return modified;\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      if (nest === false) {\n        return Reflect.getOwnPropertyDescriptor(target, prop);\n      }\n\n      markRead(target, prop);\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n\n    deleteProperty(target, prop) {\n      if (nest === false) {\n        return Reflect.deleteProperty(target, prop);\n      }\n\n      const has = Reflect.has(target, prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n\n      if (has && !Reflect.has(target, prop)) {\n        markChange(target, prop);\n        markChange(target, true);\n      }\n\n      return deleted;\n    },\n\n    ownKeys(target) {\n      if (nest === false) {\n        return Reflect.ownKeys(target);\n      }\n\n      markRead(target, true);\n      return Reflect.ownKeys(target);\n    },\n\n    has(target, prop) {\n      if (nest === false) {\n        return Reflect.has(target, prop);\n      }\n\n      markRead(target, true);\n      return Reflect.has(target, prop);\n    }\n\n  });\n  return proxy;\n}\n/** 获取被代理的原始值 */\n\nfunction recover(v) {\n  if (!v) {\n    return v;\n  }\n\n  if (!encashable$1(v)) {\n    return v;\n  }\n\n  let value = v;\n\n  try {\n    getValue = v;\n    value = v.__monitorable__recover__;\n  } catch (_unused) {}\n\n  value = getValue;\n  getValue = false;\n\n  if (!value) {\n    return v;\n  }\n\n  if (typeof value === 'object') {\n    return value;\n  }\n\n  if (typeof value === 'function') {\n    return value;\n  }\n\n  return v;\n}\nfunction equal(a, b) {\n  return recover(a) === recover(b);\n}\n\nfunction exec(fn, cb, resultOnly) {\n  cb = safeify(cb);\n  let cancelList;\n  /** 取消监听 */\n\n  function cancel() {\n    if (!cancelList) {\n      return false;\n    }\n\n    const list = cancelList;\n    cancelList = undefined;\n    list.forEach(f => f());\n    return true;\n  }\n\n  function trigger() {\n    if (!cancel()) {\n      return;\n    }\n\n    cb(true);\n  }\n  const thisRead = new Map();\n  const result = observe(fn, thisRead);\n\n  if (!thisRead.size) {\n    cb(false);\n\n    if (resultOnly) {\n      return result;\n    }\n\n    return {\n      result,\n\n      stop() {}\n\n    };\n  }\n\n  cancelList = [];\n\n  for (let [obj, props] of thisRead) {\n    for (const p of props) {\n      cancelList.push(watchProp(recover(obj), p, trigger));\n    }\n  }\n\n  if (resultOnly) {\n    return result;\n  }\n\n  return {\n    result,\n\n    stop() {\n      if (!cancel()) {\n        return;\n      }\n\n      cb(false);\n    }\n\n  };\n}\n\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nfunction createExecutable(fn, cb) {\n  cb = safeify(cb);\n  let cancelList;\n  /** 取消监听 */\n\n  function cancel() {\n    if (!cancelList) {\n      return false;\n    }\n\n    const list = cancelList;\n    cancelList = undefined;\n    list.forEach(f => f());\n    return true;\n  }\n\n  function trigger() {\n    if (!cancel()) {\n      return;\n    }\n\n    cb(true);\n  }\n\n  function exec() {\n    cancel();\n    const thisRead = new Map();\n\n    try {\n      return observe(fn, thisRead);\n    } catch (e) {\n      thisRead.clear();\n      throw e;\n    } finally {\n      if (thisRead.size) {\n        cancelList = [];\n\n        for (let [obj, props] of thisRead) {\n          for (const p of props) {\n            cancelList.push(watchProp(recover(obj), p, trigger));\n          }\n        }\n      } else {\n        cb(false);\n      }\n    }\n  }\n\n  exec.stop = () => {\n    if (!cancel()) {\n      return;\n    }\n\n    cb(false);\n  };\n\n  return exec;\n}\n\n/** 取消监听的方法 */\n\nconst values = new WeakSet();\nfunction isValue(x) {\n  return values.has(x);\n}\n/** 触发监听 */\n\nfunction createValue(recover, setValue, stop = () => {}, change = () => {}) {\n  function set(v, marked = false) {\n    if (!setValue) {\n      return;\n    }\n\n    try {\n      setValue(v, () => {\n        marked = true;\n      });\n    } finally {\n      if (marked) {\n        trigger();\n      }\n    }\n  }\n\n  function get() {\n    markRead(value, 'value');\n    return recover();\n  }\n\n  const value = (...v) => {\n    if (v.length) {\n      set(v[0], v[1]);\n      return v[0];\n    }\n\n    return get();\n  };\n\n  Reflect.defineProperty(value, 'value', {\n    get,\n    set,\n    enumerable: true,\n    configurable: true\n  });\n\n  function watch(cb) {\n    if (!callbacks) {\n      return () => {};\n    }\n\n    cb = safeify(cb);\n    callbacks.push(cb);\n    change();\n    let cancelled = false;\n    return () => {\n      if (cancelled) {\n        return;\n      }\n\n      cancelled = true;\n\n      if (!callbacks) {\n        return;\n      }\n\n      const index = callbacks.findIndex(a => a === cb);\n\n      if (index < 0) {\n        return;\n      }\n\n      callbacks.splice(index, 1);\n      change();\n    };\n  }\n\n  let callbacks = [];\n  Reflect.defineProperty(value, 'watch', {\n    get() {\n      return watch;\n    },\n\n    set() {},\n\n    configurable: true\n  });\n\n  const trigger = () => {\n    if (!callbacks) {\n      return;\n    }\n\n    markChange(value, 'value');\n\n    for (const cb of [...callbacks]) {\n      cb(value, false);\n    }\n  };\n\n  trigger.has = () => {\n    var _callbacks;\n\n    return Boolean((_callbacks = callbacks) === null || _callbacks === void 0 ? void 0 : _callbacks.length);\n  };\n\n  trigger.stop = () => {\n    if (!callbacks) {\n      return;\n    }\n\n    const list = callbacks;\n    callbacks = undefined;\n\n    for (const cb of [...list]) {\n      cb(value, true);\n    }\n  };\n\n  values.add(value);\n  let stoped = false;\n\n  value.stop = () => {\n    if (stoped) {\n      return;\n    }\n\n    stoped = true;\n    stop();\n    trigger.stop();\n  };\n\n  return {\n    value,\n    trigger\n  };\n}\n/**\n * 创建引用值\n * @param value 初始值\n * @param options 选项\n */\n\n\nfunction value(def, options) {\n  const proxy = options === true || options && options.proxy;\n  let source;\n  let proxyed;\n  const {\n    value\n  } = createValue(() => proxyed, (v, mark) => {\n    if (proxy) {\n      v = recover(v);\n    }\n\n    if (v === source) {\n      return;\n    }\n\n    source = v;\n    proxyed = proxy ? encase(source) : source;\n    mark();\n  });\n  value(def);\n  return value;\n}\n/**\n * 创建计算值\n * @param getter 取值方法\n * @param options 选项\n */\n\nfunction computed(getter, setter, options) {\n  if (typeof setter !== 'function') {\n    options = setter;\n    setter = undefined;\n  }\n\n  const setValue = setter;\n  const proxy = options === true || options && options.proxy;\n  let source;\n  let proxyed;\n  let stoped = false;\n  let computed = false;\n  let trigger;\n  const executable = createExecutable(getter, changed => {\n    computed = !changed;\n\n    if (changed && trigger) {\n      trigger();\n    }\n  });\n\n  function run() {\n    computed = true;\n\n    try {\n      source = executable();\n\n      if (proxy) {\n        source = recover(source);\n      }\n\n      proxyed = proxy ? encase(source) : source;\n      return proxyed;\n    } catch (e) {\n      if (!stoped) {\n        computed = false;\n      }\n\n      throw e;\n    }\n  }\n\n  let value;\n  ({\n    value,\n    trigger\n  } = createValue(() => computed || stoped ? proxyed : run(), setValue && (v => setValue(proxy ? recover(v) : v)), () => {\n    if (stoped) {\n      return;\n    }\n\n    stoped = true;\n\n    if (computed) {\n      return;\n    }\n\n    run();\n  }));\n  return value;\n}\nfunction merge(cb) {\n  let oldValue;\n  let runed = false;\n  return (v, stoped) => {\n    if (stoped) {\n      return cb(v, stoped);\n    }\n\n    const newValue = recover(v());\n\n    if (newValue === oldValue && runed) {\n      return;\n    }\n\n    runed = true;\n    oldValue = newValue;\n    cb(v, stoped);\n  };\n}\nfunction mix(source) {\n  for (const k of Reflect.ownKeys(source)) {\n    const descriptor = Reflect.getOwnPropertyDescriptor(source, k);\n\n    if (!descriptor) {\n      continue;\n    }\n\n    if (!('value' in descriptor) || 'get' in descriptor || 'set' in descriptor) {\n      continue;\n    }\n\n    const value = descriptor.value;\n\n    if (!isValue(value)) {\n      continue;\n    }\n\n    descriptor.get = () => value.value;\n\n    if (descriptor.writable) {\n      descriptor.set = v => value.value = v;\n    }\n\n    delete descriptor.value;\n    delete descriptor.writable;\n    Reflect.defineProperty(source, k, descriptor);\n  }\n\n  return source;\n}\n\nexport { computed, createExecutable, encase, encashable, equal, exec, getMapValue, isValue, markChange, markRead, merge, mix, observe, printError, recover, safeify, value, watchProp };\n//# sourceMappingURL=monitorable.esm.js.map\n","import { install } from '@neep/core';\nimport render from '.';\nimport * as monitorable from 'monitorable';\n\ninstall({ render, monitorable });\n\nexport * from '@neep/core';\n","import {\n\tMountProps,\n\tNeepElement,\n\tComponent,\n\tRootExposed,\n} from '../type';\nimport { isElement, createElement } from '../auxiliary';\nimport { isProduction } from '../constant';\nimport { devtools, getRender } from '../install';\nimport Container from './Container';\n\nexport default function render(\n\te?: NeepElement | Component,\n\tp: MountProps = {},\n): RootExposed {\n\tlet params = {...p};\n\tconst container =  new Container(\n\t\tgetRender(p.type),\n\t\tparams,\n\t\te === undefined ? [] : isElement(e) ? [e] : [createElement(e)],\n\t);\n\tif (!isProduction) {\n\t\tdevtools.renderHook(container);\n\t}\n\tconst { exposed } = container;\n\tReflect.defineProperty(exposed, '$update', {\n\t\tvalue(c?: NeepElement | Component) {\n\t\t\tcontainer.setChildren(c === undefined ? []\n\t\t\t\t: isElement(c) ? [c] : [createElement(c)]);\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$mount', {\n\t\tvalue(target?: any) {\n\t\t\tif (exposed.$mounted) { return exposed; }\n\t\t\tif (target) {\n\t\t\t\tparams.target = target;\n\t\t\t\tcontainer.setProps(params);\n\t\t\t}\n\t\t\tcontainer.mount();\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$unmount', {\n\t\tvalue() {\n\t\t\tif (!exposed.$mounted) { return; }\n\t\t\tif (exposed.$unmounted) { return; }\n\t\t\tif (exposed.$destroyed) { return container.destroy(); }\n\t\t\tcontainer.unmount();\n\t\t\treturn;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tif (params.target) {\n\t\tcontainer.mount();\n\t}\n\treturn exposed as any as RootExposed;\n}\n"],"names":["mode","monitorable","renders","Object","create","getRender","type","default","install","apis","render","list","Array","isArray","installRender","NeepError","Error","constructor","message","tag","ScopeSlot","SlotRender","Slot","Value","Container","Deliver","Template","Fragment","value","v","computed","isValue","encase","recover","setCurrent","fn","entity","oldEntity","current","checkCurrent","name","initOnly","created","constructors","initContext","context","exposed","hooks","setHook","id","hook","$_hooks","safeify","set","Set","add","delete","callHook","watch","cb","stop","s","setValue","obj","opt","includes","Reflect","defineProperty","get","configurable","enumerable","undefined","expose","deliver","delivered","isElementSymbol","Symbol","for","typeSymbol","nameSymbol","renderSymbol","isElement","createElement","attrs","children","node","key","slot","ref","Tags","argv","args","length","props","on","k","onInfo","exec","elements","n","push","concat","simple","label","text","color","auxiliary","State","Life","Element","Dev","Constant","createMountedNode","recursive2iterable","it","getLastNode","tree","component","getFirstNode","getNodes","unmount","iRender","forEach","e","remove","replace","newTree","oldTree","next","parent","insert","updateList","source","createItem","newList","mountedMap","Map","src","index","findIndex","old","item","updateItem","splice","size","last","filter","t","has","i","o","updateAll","Math","min","max","createList","all","draw","createValue","substr","update","createAll","isNode","RegExp","String","Date","toISOString","placeholder","map","mount","getSlots","slots","native","nativeList","ownKeys","el","renderSlots","createSlots","inserted","setSlots","updateProps","oldProps","define","newKeys","nObject","newDelivered","$__neep__delivered","container","slotMap","childNodes","refresh","f","result","nodes","renderNode","execSimple","execSlot","normalize","Boolean","NeepObject","cfg","$parent","_obj$parent","$component","$isContainer","$created","$destroyed","destroyed","$mounted","mounted","$unmounted","unmounted","createExposed","this","_obj$parent2","isContainer","h","createEntity","parentDelivered","_delayedRefresh","needRefresh","_needRefresh","_refresh","_refreshing","_render","canRefresh","_nodes","convert","_update","_destroy","destroy","__executed_destroy","_mount","__executed_mount","_unmount","__executed_mounted","_draw","nativeNodes","Entity","stopRender","changed","createExecutable","initRender","_stopRender","markDraw","toElement","_source$props","_source$props2","awaitDraw","requested","rootContainer","setChildren","_drawChildren","setProps","_drawContainer","content","_node","_container","drawSelf","drawChildren","drawContainer","_needDraw","_this$parent","_awaitDraw","markDrawContainer","needDraw","clear","c","_containers","window","requestAnimationFrame","drawAll","containers","Mark","symbol","getClass","split","getStyle","style","css","toLowerCase","stringify","data","isOn","toString","JSON","getAttrs","getEvent","evt","PropsMap","WeakMap","event","classes","class","className","getProps","removeAttribute","oClasses","getAttribute","classList","setAttribute","join","updateClass","oStyle","keys","setProperty","removeProperty","cssText","updateStyle","oAttrs","updateAttrs","oEvt","oSet","addEventListener","removeEventListener","updateEvent","Node","target","test","document","querySelector","appendChild","body","removed","oldTarget","newNode","pNode","createTextNode","createComment","attachShadow","parentNode","nextSibling","insertBefore","p","removeChild","printErrorLog","printError","info","print","console","encashable","getMapValue","def","r","marks","m","params"],"mappings":"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"}