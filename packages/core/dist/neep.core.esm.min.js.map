{"version":3,"file":"neep.core.esm.min.js","sources":["../src/constant.ts","../src/Error.ts","../src/install.ts","../src/auxiliary/tags.ts","../src/helper/current.ts","../src/helper/context.ts","../src/hook.ts","../src/auxiliary/life.ts","../src/symbols.ts","../src/auxiliary/element.ts","../src/auxiliary/dev.ts","../src/auxiliary/index.ts","../src/render/id.ts","../src/render/recursive.ts","../src/render/draw.ts","../src/render/slot.ts","../src/render/props.ts","../src/render/normalize.ts","../src/render/refresh.ts","../src/render/Object.ts","../src/render/Entity.ts","../src/render/convert.ts","../src/render/Container.ts","../src/render/index.ts","../src/create.ts"],"sourcesContent":["/**\n * Global constant\n *\n * Will be replaced by the 'rollup-plugin-replace' plug-in\n */\n\n /**\n * Neep code version\n */\nexport const version = '__VERSION__' as string;\n/**\n * Current mode\n * @enum production\n * @enum development\n */\nexport const mode = '__MODE__' as any as 'production' | 'development';\n/**\n * Is the current mode production mode\n * @description Support tree shaking\n */\nexport const isProduction = mode === 'production';\n","export default class NeepError extends Error {\n\treadonly tag: string;\n\tconstructor(message: string, tag: string = '') {\n\t\tsuper(tag ? `[${tag}] ${message}` : message);\n\t\tthis.tag = tag;\n\t}\n}\nexport function assert(v: any, message: string, tag?: string) {\n\tif (v) { return; }\n\tthrow new NeepError(message, tag);\n}","import * as monitorableApi from 'monitorable';\nimport { IRender } from './type';\nimport { isProduction } from './constant';\n\nimport { Devtools } from '../../devtools/src/type';\nimport { assert } from './Error';\n\nexport let monitorable: typeof monitorableApi;\n\nexport let value: typeof monitorableApi.value;\nexport let computed: typeof monitorableApi.computed;\nexport let isValue: typeof monitorableApi.isValue;\nexport let encase: typeof monitorableApi.encase;\nexport let recover: typeof monitorableApi.recover;\n\nfunction installMonitorable(api?: typeof monitorableApi) {\n\tif (!api) { return; }\n\tmonitorable = api;\n\tvalue = monitorable.value;\n\tcomputed = monitorable.computed;\n\tisValue = monitorable.isValue;\n\tencase = monitorable.encase;\n\trecover = monitorable.recover;\n}\n\nexport interface InstallOptions {\n\tmonitorable?: typeof monitorableApi;\n\trender?: IRender;\n\trenders?: IRender[];\n\tdevtools?: any;\n}\n\n\nlet nextFrameApi: undefined | ((fn: () => void) => void);\nexport function nextFrame(fn: () => void): void {\n\tassert(nextFrameApi, 'The basic renderer is not installed', 'install');\n\tnextFrameApi!(fn);\n}\n\nexport const renders: Record<string, IRender>\n\t= Object.create(null);\n\nexport function getRender(\n\ttype: string | number | IRender = ''\n\t): IRender {\n\tif (typeof type === 'object') { return type; }\n\treturn renders[type] || renders.default;\n}\n\nfunction addRender(render?: IRender): void {\n\tif (!render) { return; }\n\trenders[render.type] = render;\n\tif (nextFrameApi) { return; }\n\tif (!renders.default) {\n\t\trenders.default = render;\n\t}\n\tif (!nextFrameApi && render.nextFrame) {\n\t\trenders.default = render;\n\t\tnextFrameApi = render.nextFrame;\n\t}\n\n}\nfunction installRender({ render, renders}: InstallOptions) {\n\taddRender(render);\n\tif (!Array.isArray(renders)) { return; }\n\tfor (const render of renders) {\n\t\taddRender(render);\n\t}\n}\n\n\nexport const devtools: Devtools = {\n\trenderHook(){},\n};\n\nfunction installDevtools(tools?: Partial<Devtools>) {\n\tif (!tools) { return; }\n\tif (typeof tools !== 'object') { return; }\n\tconst { renderHook } = tools;\n\tif (typeof renderHook === 'function') {\n\t\tdevtools.renderHook = renderHook;\n\t}\n}\n\n\nexport default function install(apis: InstallOptions) {\n\tinstallMonitorable(apis.monitorable);\n\tinstallRender(apis);\n\tif (!isProduction) {\n\t\tinstallDevtools(apis.devtools);\n\t}\n}\n","export const ScopeSlot = 'Neep:ScopeSlot';\nexport const SlotRender = 'Neep:SlotRender';\nexport const Slot = 'Neep:Slot';\nexport const Value = 'Neep:Value';\nexport const Container = 'Neep:Container';\nexport const Deliver = 'Neep:Deliver';\nexport const Template = 'template';\nexport const Fragment = Template;\n","import NeepError from '../Error';\nimport { Entity } from '../type';\n\n/** 当前正在执行的对象 */\nexport let current: Entity | undefined;\nexport function setCurrent<T>(\n\tfn: () => T,\n\tentity: Entity,\n): T {\n\tconst oldEntity = current;\n\tcurrent = entity;\n\ttry {\n\t\tcurrent.$_valueIndex = 0;\n\t\tconst ret = fn();\n\t\tif (current.$_valueIndex !== current.$_values.length) {\n\t\t\tthrow new NeepError(\n\t\t\t\t'Inconsistent number of useValue executions',\n\t\t\t\t'life',\n\t\t\t);\n\t\t}\n\t\treturn ret;\n\t} finally {\n\t\tcurrent = oldEntity;\n\t}\n}\n\nexport function checkCurrent(\n\tname: string,\n\tinitOnly = false,\n): Entity {\n\tif (!current) {\n\t\tthrow new NeepError(\n\t\t\t`Function \\`${name}\\` can only be called within a cycle.`,\n\t\t\t'life',\n\t\t);\n\t}\n\tif (!initOnly) {\n\t\treturn current;\n\t}\n\tif (!current.created) {\n\t\treturn current;\n\t}\n\tthrow new NeepError(\n\t\t`Function \\`${name}\\` can only be called at initialization time.`,\n\t\t'life',\n\t);\n}\n","import { Context, ContextConstructor, Exposed } from '../type';\nimport { monitorable } from '../install';\n\nconst constructors: ContextConstructor[] = [];\nexport function initContext(\n\tcontext: Context,\n\texposed?: Exposed,\n): Context {\n\tfor (const constructor of constructors) {\n\t\tconstructor(context, exposed);\n\t}\n\treturn context;\n}\nexport function addContextConstructor(\n\tconstructor: ContextConstructor\n): void {\n\tconstructors.push(monitorable.safeify(constructor));\n}","import { monitorable } from './install';\nimport { Hook, Hooks, Entity } from './type';\nconst hooks: Record<string, Set<Hook>> = Object.create(null);\n\nexport function setHook<H extends Hooks>(\n\tid: H,\n\thook: Hook,\n\tentity?: Entity,\n):() => void;\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n): () => void;\n\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n):() => void {\n\tlet list = entity?.$_hooks || hooks;\n\tif (!list) { return () => {}; }\n\thook = monitorable.safeify(hook);\n\tlet set = list[id];\n\tif (!set) {\n\t\tset = new Set();\n\t\tlist[id] = set;\n\t}\n\tset.add(hook);\n\treturn () => set.delete(hook);\n}\n\nexport function callHook<H extends Hooks>(\n\tid: H,\n\texposed: Entity,\n): void;\nexport function callHook(id: string, exposed: Entity): void;\nexport function callHook(id: string, exposed: Entity): void {\n\tif (!exposed) { return; }\n\tfor (const hook of exposed.$_hooks[id] || []) {\n\t\thook(exposed);\n\t}\n\tfor (const hook of hooks[id] || []) {\n\t\thook(exposed);\n\t}\n}\n","/**********************************\n * 组件上下文环境专用 API\n * @description 简单组件不支持\n **********************************/\nimport { Value, WatchCallback } from 'monitorable';\nimport { Hooks } from '../type';\nimport { checkCurrent } from '../helper';\nimport NeepError from '../Error';\nimport { setHook } from '../hook';\nimport { isValue, value, computed } from './state';\n\n\n/**********************************\n * 状态管理类 API\n **********************************/\n/**\n * 监听指定值的变化\n * @description 本质是调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 被监听的值\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: Value<T>,\n\tcb: WatchCallback<T>,\n): () => void;\n/**\n * 监听指定值的变化\n * @description 本质是创建调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 用于计算观测值的函数\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: () => T,\n\tcb: (v: T, stopped: boolean) => void,\n): () => void;\n\nexport function watch<T>(\n\tvalue: Value<T> | (() => T),\n\tcb: (v: Value<T> | T, stopped: boolean) => void\n): () => void {\n\tconst entity = checkCurrent('watch');\n\tif (typeof value !== 'function') { return () => {}; }\n\tconst stop = isValue(value)\n\t\t? value.watch(cb)\n\t\t: computed(value).watch((v, s) => cb(v(), s));\n\tsetHook('beforeDestroy', () => stop(), entity);\n\treturn stop;\n}\n\nexport function useValue(): Value<any>;\nexport function useValue<T>(fn: () => T, name?: string): T;\nexport function useValue<T>(fn?: () => T, name?: string): T | Value<any>;\nexport function useValue<T>(fn?: () => T, name = 'useValue'): T | Value<any> {\n\tconst entity = checkCurrent(name);\n\tconst index = entity.$_valueIndex++;\n\tconst values = entity.$_values;\n\tif (!entity.created) {\n\t\tvalues[index] = undefined;\n\t\tconst v = typeof fn === 'function' ? fn() : value(undefined);\n\t\treturn values[index] = v;\n\t}\n\tif (index >= values.length) {\n\t\tthrow new NeepError(\n\t\t\t'Inconsistent number of useValue executions',\n\t\t\t'life',\n\t\t);\n\t}\n\treturn values[index];\n\n}\n\n/**********************************\n * 钩子类 API\n **********************************/\n/**\n * 为当前组件注册钩子\n * @param name 钩子名称\n * @param hook 钩子\n * @param initOnly 是否仅在初始化时有效\n */\nexport function hook<H extends Hooks>(\n\tname: H,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void) {\n\tconst entity = checkCurrent('setHook');\n\tif (initOnly && entity.created) { return undefined; }\n\treturn setHook(name, () => hook(), entity);\n}\n\n/**********************************\n * 配置 API\n **********************************/\n\nexport function setValue<T>(\n\tobj: any,\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tif (\n\t\ttypeof name === 'string'\n\t\t&& ['$', '_'].includes(name[0])\n\t) {\n\t\treturn;\n\t}\n\tif (isValue(value) && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget() { return value(); },\n\t\t\tset(v) { value(v); },\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tif (typeof value === 'function' && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget: value as () => T,\n\t\t\tset: typeof opt === 'function' ? opt : undefined,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tReflect.defineProperty(obj, name, {\n\t\tget() { return value; },\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\n\n\n/**\n * 将 Value 导出\n * @param name 导出用的名称\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的导出\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的导出\n * @param name\n * @param getter\n * @param setter\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('expose', true).exposed, name, value, opt);\n}\n\n\n/**\n * 将 Value 传递给子组件\n * @param name 导出用的名称\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的传递\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的传递\n * @param name\n * @param getter\n * @param setter\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('deliver', true).delivered, name, value, opt);\n}\n","export const isElementSymbol = Symbol.for('isNeepElement');\nexport const typeSymbol = Symbol.for('type');\nexport const nameSymbol = Symbol.for('name');\nexport const renderSymbol = Symbol.for('render');\n","import { Tag, NeepElement, Component } from '../type';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport * as Tags from './tags';\n\n/**\n * 判读是否为元素\n */\nexport function isElement(v: any): v is NeepElement {\n\tif (!v) { return false; }\n\tif (typeof v !== 'object') { return false; }\n\treturn v[isElementSymbol] === true;\n}\n\nexport function createElement(\n\ttag: Tag,\n\tattrs?: {[key:string]: any},\n\t...children: any[]\n): NeepElement {\n\tattrs = attrs ? {...attrs} : {};\n\tconst node: NeepElement = {\n\t\t[isElementSymbol]: true,\n\t\ttag,\n\t\tchildren: [],\n\t};\n\tif ('key' in attrs) { node.key = attrs.key; }\n\tif ('slot' in attrs) { node.slot = attrs.slot; }\n\tif (typeof attrs.ref === 'function') { node.ref = attrs.ref; }\n\tif (tag === Tags.Value) {\n\t\tnode.value = attrs.value;\n\t\treturn node;\n\t}\n\tnode.children = children;\n\tif (tag === Tags.Template) { return node; }\n\tif (tag === Tags.SlotRender) {\n\t\tnode.render = attrs.render;\n\t\treturn node;\n\t}\n\tif (tag === Tags.ScopeSlot || tag === Tags.Slot) {\n\t\tconst { render, argv, args, name } = attrs;\n\t\tnode.render = render;\n\t\tnode.args = argv && [argv]\n\t\t\t|| Array.isArray(args) && args.length && args\n\t\t\t|| [{}];\n\n\t\tif (tag === Tags.ScopeSlot) {\n\t\t\tnode.props = { name };\n\t\t\treturn node;\n\t\t}\n\t}\n\tnode.on = {};\n\tnode.props = {};\n\tfor (let k in attrs) {\n\t\t/** 事件 */\n\t\tconst onInfo = /^(::|@|on:)([a-zA-Z0-9].*)$/.exec(k);\n\t\tif (onInfo) {\n\t\t\tnode.on[onInfo[2]] = attrs[k];\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: data\n\t\tconst nCmd = /^n([:-])([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*)$/i.exec(k);\n\t\t/** 普通属性 */\n\t\tif (!nCmd) {\n\t\t\tnode.props[k] = attrs[k];\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn node;\n}\n\nexport interface elementIteratorOptions {\n\tsimple?: boolean | Component[] | ((c: Component) => boolean);\n}\n\nexport function elements(\n\tnode: any,\n\topt: elementIteratorOptions = {},\n): any[] {\n\tif (Array.isArray(node)) {\n\t\tconst list: any[][] = [];\n\t\tfor (let n of node) {\n\t\t\tlist.push(elements(n, opt));\n\t\t}\n\t\treturn ([] as any[]).concat(...list);\n\t}\n\tif (!isElement(node)) { return [node]; }\n\tlet { tag } = node;\n\tif (!tag) { return []; }\n\n\tif (([Tags.Template, Tags.ScopeSlot] as Tag[]).includes(tag)) {\n\t\treturn elements(node.children, opt);\n\t}\n\tif (typeof tag !== 'function') { return [node]; }\n\tif (tag[typeSymbol] !== 'simple') { return [node]; }\n\tconst { simple } = opt;\n\tif (!simple) { return [node]; }\n\tif (Array.isArray(simple)) {\n\t\tif (simple.includes(tag)) { return [node]; }\n\t} else if (typeof simple === 'function') {\n\t\tif (!simple(tag)) { return [node]; }\n\t}\n\treturn elements(node.children, opt);\n}\n","import { isProduction } from '../constant';\nimport { current } from '../helper';\nimport { setLabel } from '../helper/label';\n\nexport function label(text: string, color = ''): void {\n\tif (!isProduction) {\n\t\tif (!current) {\n\t\t\tsetLabel([text, color]);\n\t\t\treturn;\n\t\t}\n\t\tReflect.defineProperty(current.exposed, '$label', {\n\t\t\tvalue: [text, color],\n\t\t\tconfigurable: true,\n\t\t});\n\t}\n}\n","import * as Constant from '../constant';\nimport * as Tags from './tags';\nimport * as State from './state';\nimport * as Life from './life';\nimport * as Element from './element';\nimport * as Dev from './dev';\n\nexport * from './tags';\nexport * from './state';\nexport * from './life';\nexport * from './element';\nexport * from './dev';\n\nexport { Tags };\n\n/** 辅助 */\nexport interface Auxiliary extends\n\tReadonly<typeof Tags>,\n\tReadonly<typeof State>,\n\tReadonly<typeof Life>,\n\tReadonly<typeof Element>,\n\tReadonly<typeof Dev>,\n\tReadonly<typeof Constant>\n{}\n\nconst auxiliary: Auxiliary = {\n\t...Tags,\n\t...Life,\n\t...Element,\n\t...Dev,\n\t...Constant,\n\tget value() { return State.value },\n\tget computed() { return State.computed },\n\tget isValue() { return State.isValue },\n\tget encase() { return State.encase },\n\tget recover() { return State.recover },\n};\n\nexport function setAuxiliary<T>(\n\tname: string,\n\tvalue: T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tvalue,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport function defineAuxiliary<T>(\n\tname: string,\n\tget: (this: Auxiliary) => T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tget,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport default auxiliary;\n","import { NativeNode } from '../type';\nimport { isProduction } from '../constant';\nimport { MountedNode } from './draw';\n\nlet ids = 0;\nconst Nodes: {[key: number]: MountedNode} = {};\nlet IdMap: undefined | Map<NativeNode, number>;\nif (!isProduction) {\n\tIdMap = new Map();\n}\nexport function createMountedNode(\n\tn: Omit<MountedNode, 'id'>,\n\tid?: number,\n): MountedNode {\n\tif (!isProduction) {\n\t\tid = id || ++ids;\n\t\tconst { node } = n;\n\t\tif (node && IdMap) { IdMap.set(node, id); }\n\t\treturn Nodes[id] = {...n, id};\n\t}\n\treturn {...n, id: 0};\n}\n\nexport function recoveryMountedNode(node: MountedNode): void {\n\tif (!isProduction) {\n\t\tdelete Nodes[node.id];\n\t}\n}\n\nexport function getNode(\n\tid: number | NativeNode,\n): MountedNode | undefined {\n\tif (!isProduction) {\n\t\tif (typeof id !== 'number') {\n\t\t\tid = IdMap?.get(id) || -1;\n\t\t}\n\t\treturn Nodes[id];\n\t}\n\treturn undefined;\n}\n","export interface RecursiveArray<T> extends Array<RecursiveItem<T>>{};\nexport type RecursiveItem<T> = T | RecursiveArray<T>;\n\nexport function *recursive2iterable<T>(\n\tlist: RecursiveItem<T>,\n): Iterable<T> {\n\tif (!Array.isArray(list)) {\n\t\tyield list;\n\t\treturn;\n\t}\n\tfor (const it of list) {\n\t\tyield* recursive2iterable(it);\n\t}\n}\n","import { Tags, Template } from '../auxiliary';\nimport { IRender, NativeNode, NativeElement } from '../type';\nimport { createMountedNode, recoveryMountedNode } from './id';\nimport { TreeNode } from './convert';\n\n/**\n * @description node / component / children 至少一个有效\n */\nexport interface MountedNode extends TreeNode {\n\tid: number;\n\tparent?: this;\n\tnode: undefined | NativeNode;\n}\n\n\ntype MountedNodes = MountedNode | MountedNode[]\n\t| (MountedNode | MountedNode[])[];\n\nfunction getLastNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) {\n\t\treturn getLastNode(tree[tree.length - 1]);\n\t}\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getLastNode(component.tree); }\n\treturn getLastNode(children);\n}\n\nfunction getFirstNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) { return getFirstNode(tree[0]); }\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getFirstNode(component.tree); }\n\treturn getFirstNode(children[0]);\n}\n\nexport function *getNodes(tree: MountedNodes): Iterable<NativeNode> {\n\tif (Array.isArray(tree)) {\n\t\tfor (const it of tree) {\n\t\t\tyield* getNodes(it);\n\t\t}\n\t\treturn;\n\t}\n\tconst { children, node, component } = tree;\n\tif (node) {\n\t\tyield node;\n\t\treturn;\n\t}\n\tif (component) {\n\t\tyield* getNodes(component.tree);\n\t\treturn;\n\t}\n\tyield* getNodes(children);\n}\n\nexport function unmount(iRender: IRender, tree: MountedNodes): void {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(e => unmount(iRender, e));\n\t\treturn;\n\t}\n\tconst { component, children, node, ref } = tree;\n\trecoveryMountedNode(tree);\n\tif (node) {\n\t\tif (ref) { ref(node, true); }\n\t\tiRender.remove(node);\n\t\treturn;\n\t}\n\tif (component) {\n\t\tif (ref) { ref(component.exposed, true); }\n\t\tcomponent.unmount();\n\t\treturn;\n\t}\n\tunmount(iRender, children);\n}\n\n\nfunction replace<T extends MountedNode | MountedNode[]>(\n\tiRender: IRender,\n\tnewTree: T,\n\toldTree: MountedNode | MountedNode[],\n): T {\n\tconst next = getFirstNode(oldTree);\n\tif (!next) { return newTree; }\n\tconst parent = iRender.parent(next);\n\tif (!parent) { return newTree; }\n\tfor (const it of getNodes(newTree)) {\n\t\tiRender.insert(parent, it, next);\n\t}\n\tunmount(iRender, oldTree);\n\treturn newTree;\n}\n\nfunction updateList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n\ttree: MountedNode | MountedNode[],\n): MountedNode[] {\n\tif (!source.length) {\n\t\tconst node = createItem(iRender, {tag: null, children: []});\n\t\treturn [replace(iRender, node, tree)];\n\t}\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: MountedNode[] = [];\n\tconst list = [...tree];\n\tconst mountedMap = new Map<MountedNode, MountedNode>();\n\tfor (const src of source) {\n\t\tconst index = list.findIndex(it =>\n\t\t\tit.tag === src.tag && it.key === src.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tconst old = list[index];\n\t\t\tconst item = updateItem(iRender, src, old);\n\t\t\tmountedMap.set(old, item);\n\t\t\tnewList.push(item);\n\t\t\tlist.splice(index, 1);\n\t\t} else {\n\t\t\tconst item = createItem(iRender, src);\n\t\t\tnewList.push(item);\n\t\t}\n\t}\n\tif (!mountedMap.size) {\n\t\treturn replace(iRender, newList, list);\n\t}\n\tunmount(iRender, list);\n\ttree = tree.filter(t => mountedMap.has(t));\n\tconst last = getLastNode(tree[tree.length - 1]);\n\tconst parent = iRender.parent(last);\n\tif (!parent) { return newList; }\n\tlet next = iRender.next(last);\n\t// 调整次序\n\tfor(let i = newList.length - 1; i >= 0; i--) {\n\t\tconst item = newList[i];\n\t\tconst index = tree.findIndex(o => mountedMap.get(o) === item);\n\t\tif (index >= 0) {\n\t\t\tfor (const it of tree.splice(index)) {\n\t\t\t\tmountedMap.delete(it);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t\tnext = getFirstNode(item) || next;\n\t}\n\treturn newList;\n}\n/**\n * 更新树\n * @param tree 已有树\n * @param source 用于替换的源\n * @param iRender Neep 对象\n */\nfunction updateAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length || 1);\n\tconst list: (MountedNode | MountedNode[])[] = [];\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tlist.push(updateList(iRender, src, tree[index]));\n\t\t} else {\n\t\t\tlist.push(updateItem(iRender, src, tree[index]));\n\t\t}\n\t}\n\tlength = Math.max(source.length, tree.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\tunmount(iRender, tree[index]);\n\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tconst last = getLastNode(list[list.length - 1]);\n\t\tconst parent = iRender.parent(last);\n\t\tconst next = iRender.next(last);\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = source[index];\n\t\t\tconst item = Array.isArray(src)\n\t\t\t\t? createList(iRender, src)\n\t\t\t\t: createItem(iRender, src);\n\t\t\tlist.push(item);\n\t\t\tif (!parent) { continue; }\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\n/**\n * 更新树节点\n * @param iRender Neep 对象\n * @param tree 已有树\n * @param source 用于替换的源\n */\nfunction updateItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n\ttree: MountedNode | MountedNode[],\n): MountedNode {\n\tif (Array.isArray(tree)) {\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === source.tag && it.component === source.component\n\t\t);\n\t\tif (index < 0) {\n\t\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tunmount(iRender, all);\n\t}\n\tconst { tag, component } = source;\n\tconst ref = source.ref !== tree.ref && source.ref;\n\tif (tag !== tree.tag || component !== tree.component) {\n\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t}\n\tif (!tag) { return tree; }\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(\n\t\t\t\t\tiRender,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t}, tree.id);\n\t\t}\n\t\tif (ref) { ref(component.exposed); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent,\n\t\t\tchildren: [],\n\t\t}, tree.id);\n\t}\n\tif (tag === Tags.Value) {\n\t\tif(tree.value === source.value) {\n\t\t\tif (ref && tree.node) { ref(tree.node); }\n\t\t\treturn createMountedNode({\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tchildren: [],\n\t\t\t}, tree.id);\n\t\t}\n\t\treturn replace( iRender, createValue(iRender, source), tree);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: updateAll(\n\t\t\t\tiRender,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t}, tree.id);\n\t}\n\tconst { node } = tree;\n\tiRender.update(\n\t\tnode as NativeElement,\n\t\tsource.props || {},\n\t);\n\tif (ref) { ref(node!); }\n\tif (!source.children.length && !tree.children.length) {\n\t\treturn createMountedNode(\n\t\t\t{\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tchildren: [],\n\t\t\t},\n\t\t\ttree.id);\n\t}\n\tif (!source.children.length && tree.children.length) {\n\t\tunmount(iRender, tree.children);\n\t}\n\tif (source.children.length && !tree.children.length) {\n\t\tconst children = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node as NativeElement, it);\n\t\t}\n\t\treturn createMountedNode({\n\t\t\t...tree,\n\t\t\t...source,\n\t\t\tchildren,\n\t\t}, tree.id);\n\t}\n\treturn createMountedNode({\n\t\t...tree, ...source,\n\t\tchildren: updateAll(\n\t\t\tiRender,\n\t\t\tsource.children,\n\t\t\ttree.children,\n\t\t),\n\t}, tree.id);\n}\n\nfunction createValue(\n\tiRender: IRender,\n\tsource: TreeNode,\n): MountedNode {\n\tconst { value, ref } = source;\n\tif (iRender.isNode(source.value)) {\n\t\tif (ref) { ref(value); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: value,\n\t\t\tchildren: [],\n\t\t\tcomponent: undefined,\n\t\t});\n\t}\n\tconst type = typeof value;\n\tlet node: NativeNode | undefined;\n\tif (\n\t\ttype === 'bigint'\n\t\t|| type === 'boolean'\n\t\t|| type === 'number'\n\t\t|| type === 'string'\n\t\t|| type === 'symbol'\n\t\t|| value instanceof RegExp\n\t) {\n\t\tnode = iRender.text(String(value));\n\t} else if (value instanceof Date) {\n\t\tnode = iRender.text(value.toISOString());\n\t} else if (type === 'object' && value) {\n\t\tnode = iRender.text(String(value));\n\t\t// TODO: 对象处理\n\t}\n\tif (!node) { node = iRender.placeholder(); }\n\tif (ref) { ref(node); }\n\treturn createMountedNode({\n\t\t...source,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t});\n}\n\nfunction createAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (!source.length) {\n\t\treturn [createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode: iRender.placeholder(),\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t})];\n\t}\n\n\treturn source.map(item =>\n\t\tArray.isArray(item)\n\t\t\t? createList(iRender, item)\n\t\t\t: createItem(iRender, item)\n\t);\n}\n\nfunction createList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n): MountedNode[] {\n\tif (source.length) {\n\t\treturn source.map(it => createItem(iRender, it));\n\t}\n\treturn [createMountedNode({\n\t\ttag: null,\n\t\tnode: iRender.placeholder(),\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t})];\n}\n\nfunction createItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n): MountedNode {\n\tconst { tag, ref, component } = source;\n\tif (!tag) {\n\t\tconst node = iRender.placeholder();\n\t\tif (ref) { ref(node); }\n\t\treturn createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t});\n\t}\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(iRender, source.children),\n\t\t\t});\n\t\t}\n\t\tcomponent.mount();\n\t\tif (ref) { ref(component.exposed); }\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent, children: [],\n\t\t});\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn createValue(iRender, source);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: createAll(iRender, source.children),\n\t\t});\n\t}\n\tconst node = iRender.create(tag, source.props || {});\n\tif (ref) { ref(node); }\n\tlet children: (MountedNode | MountedNode[])[] = [];\n\tif (source.children) {\n\t\tchildren = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node, it);\n\t\t}\n\t}\n\treturn createMountedNode({\n\t\t...source,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren,\n\t});\n}\n\nexport default function draw(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree?: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (tree) {\n\t\treturn updateAll(iRender, source, tree);\n\t}\n\treturn createAll(iRender, source);\n}\n","import { NeepElement, SlotFn, Slots, IRender } from '../type';\nimport { isElement, SlotRender, ScopeSlot } from '../auxiliary';\nimport { isElementSymbol } from '../symbols';\nimport { isProduction } from '../constant';\n\n\nexport function getSlots(\n\tiRender: IRender,\n\tchildren: any[],\n\tslots: Record<string | symbol, any[]>,\n\tnative = false,\n): any[] {\n\t/** 原始对象 */\n\tconst nativeList: any[] = [];\n\tfor (const it of children) {\n\t\tif (Array.isArray(it)) {\n\t\t\tconst list: Record<string | symbol, any[]>\n\t\t\t\t= Object.create(null);\n\t\t\tnativeList.push(getSlots(iRender, it, list, native));\n\t\t\tfor (const k of Reflect.ownKeys(list) as string[]) {\n\t\t\t\tif (k in slots) {\n\t\t\t\t\tslots[k].push(list[k]);\n\t\t\t\t} else {\n\t\t\t\t\tslots[k] = [list[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (native) {\n\t\t\tif (iRender.isNode(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isElement(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (it.tag !== SlotRender) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconst slot = isElement(it) && it.slot || 'default';\n\t\tconst el = isElement(it) ? {\n\t\t\t...it, slot: undefined,\n\t\t\tprops: {...it.props, slot: undefined },\n\t\t} : it;\n\t\tif (slot in slots) {\n\t\t\tslots[slot].push(el);\n\t\t} else {\n\t\t\tslots[slot] = [el];\n\t\t}\n\t}\n\treturn nativeList;\n}\nfunction renderSlots(\n\tlist: any[],\n\t...props: any\n): any[] {\n\treturn list.map(it => {\n\t\tif (Array.isArray(it)) {\n\t\t\treturn renderSlots(it, ...props);\n\t\t}\n\t\tif (!isElement(it)) { return it; }\n\t\tif (it.tag !== SlotRender) {\n\t\t\treturn {\n\t\t\t\t...it,\n\t\t\t\tslot: undefined,\n\t\t\t} as NeepElement;\n\t\t}\n\t\tif (typeof it.render === 'function') {\n\t\t\treturn it.render(...props);\n\t\t}\n\t\treturn it.children;\n\t});\n}\nfunction createSlots(\n\tname: string,\n\tlist: any[],\n): SlotFn {\n\tconst slot = (...props: any) => ({\n\t\t[isElementSymbol]: true,\n\t\ttag: ScopeSlot,\n\t\tchildren: renderSlots(list, ...props),\n\t\tinserted: true,\n\t\tlabel: isProduction ? undefined : [`[${name}]`, '#00F'],\n\t} as NeepElement);\n\tslot.children = list;\n\treturn slot;\n}\nexport function setSlots(\n\tchildren: {[key: string]: any[]},\n\tslots: Slots = Object.create(null),\n) {\n\tfor (const k of Reflect.ownKeys(slots)) {\n\t\tif (!(k in children)) {\n\t\t\tdelete slots[k as string];\n\t\t}\n\t}\n\tfor (const k of Reflect.ownKeys(children) as string[]) {\n\t\tslots[k] = createSlots(k, children[k]);\n\t}\n\treturn slots;\n}\n","import { isValue } from '../auxiliary';\n\nexport function updateProps(\n\tobj: any,\n\tprops: any,\n\toldProps: any = {},\n\tdefine = false,\n) {\n\tconst newKeys = new Set(Reflect.ownKeys(props));\n\tfor (const k of Reflect.ownKeys(obj)) {\n\t\tif (!newKeys.has(k)) {\n\t\t\tdelete obj[k];\n\t\t}\n\t}\n\tif (!define) {\n\t\tfor (const k of newKeys) {\n\t\t\tobj[k] = props[k];\n\t\t}\n\t\treturn obj;\n\t}\n\tfor (const k of newKeys) {\n\t\tconst value = props[k];\n\t\tif (k in oldProps && oldProps[k] === value) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (isValue(value)) {\n\t\t\tReflect.defineProperty(obj, k, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget() { return value(); },\n\t\t\t\tset(v) { value(v); }\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tReflect.defineProperty(obj, k, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue,\n\t\t});\n\t}\n\treturn obj;\n}","import {\n\tNeepElement, Exposed, Delivered,\n\tRender, NeepNode, Slots, Context, IRender, Component,\n} from '../type';\nimport { typeSymbol } from '../symbols';\nimport { isProduction } from '../constant';\nimport auxiliary, { isElement, Tags } from '../auxiliary';\nimport { renderSymbol, isElementSymbol } from '../symbols';\nimport { getLabel } from '../helper/label';\nimport Container from './Container';\nimport Entity from './Entity';\nimport { getSlots, setSlots } from './slot';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\n\nfunction execSimple(\n\tnObject: Container | Entity,\n\tdelivered: Delivered,\n\tnode: NeepElement,\n\ttag: Component,\n\tchildren: any[],\n) {\n\tconst { iRender } = nObject.container;\n\tconst slotMap = Object.create(null);\n\tgetSlots(iRender, children, slotMap);\n\tconst slots = setSlots(slotMap);\n\tconst context: Context = initContext({\n\t\tslots,\n\t\tcreated: false,\n\t\tparent: nObject.exposed,\n\t\tdelivered,\n\t\tchildren: new Set<Exposed>(),\n\t\tchildNodes: children,\n\t\trefresh(f) { nObject.refresh(f); }\n\t});\n\tif (!isProduction) { getLabel(); }\n\tconst result = tag({...node.props}, context, auxiliary);\n\tlet label: [string, string] | undefined;\n\tif (!isProduction) { label = getLabel(); }\n\tconst nodes = exec(nObject, delivered, renderNode(\n\t\tiRender,\n\t\tresult,\n\t\tcontext,\n\t\ttag[renderSymbol],\n\t), slots);\n\n\treturn {\n\t\t...node,\n\t\tchildren: Array.isArray(nodes) ? nodes : [nodes],\n\t\tlabel,\n\t} as NeepElement;\n}\n\nfunction execSlot(\n\tnode: NeepElement,\n\tslots: Slots,\n\tchildren: any[],\n\targs: any[] = [{}],\n): NeepElement {\n\tconst slotName = node.props?.name || 'default';\n\tconst slot = slots[slotName];\n\tif (typeof slot === 'function') {\n\t\treturn {\n\t\t\t...node,\n\t\t\t...slot(...args),\n\t\t};\n\t}\n\tconst { render } = node;\n\tconst label: [string, string] | undefined = isProduction\n\t\t? undefined\n\t\t: [`[${ slotName }]`, '#00F'];\n\treturn {\n\t\t...node,\n\t\ttag: Tags.ScopeSlot,\n\t\tlabel,\n\t\tchildren:\n\t\t\ttypeof render !== 'function' ? children : render(...args),\n\t};\n}\n\nfunction exec(\n\tnObject: Container | Entity,\n\tdelivered: Delivered,\n\tnode: any,\n\tslots: Slots,\n\tnative = false,\n): any {\n\tif (Array.isArray(node)) {\n\t\treturn node.map(n =>\n\t\t\texec(nObject, delivered, n, slots, native)\n\t\t);\n\t}\n\tif (!isElement(node)) { return node; }\n\tlet { tag, inserted, args = [{}] } = node;\n\tif (tag === Tags.Deliver) {\n\t\tconst props = { ...node.props };\n\t\tdelete props.ref;\n\t\tdelete props.slot;\n\t\tdelete props.key;\n\t\tconst newDelivered = Object.create(delivered);\n\t\tupdateProps(newDelivered, props || {}, {}, true);\n\t\treturn {\n\t\t\t...node,\n\t\t\ttag,\n\t\t\t$__neep__delivered: newDelivered,\n\t\t\tchildren: node.children.map(n => exec(\n\t\t\t\tnObject,\n\t\t\t\tnewDelivered,\n\t\t\t\tn,\n\t\t\t\tslots,\n\t\t\t\tnative,\n\t\t\t)),\n\t\t};\n\t}\n\n\tconst children = node.children\n\t\t.map(n => exec(nObject, delivered, n, slots, native));\n\n\tif (typeof tag === 'function') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn execSimple(nObject, delivered, node, tag, children);\n\t\t}\n\t\treturn { ...node, $__neep__delivered: delivered, children, tag };\n\n\t}\n\tif (tag === Tags.Slot) {\n\t\ttag = native ? 'slot' : Tags.ScopeSlot;\n\t}\n\tif (tag !== Tags.ScopeSlot || inserted) {\n\t\treturn { ...node, children, tag };\n\t}\n\treturn execSlot(node, slots, children, args);\n}\n\n\n\nfunction renderNode<R extends object = object>(\n\tiRender: IRender,\n\tnode: R | NeepNode | NeepNode[] | undefined | null,\n\tcontext: Context,\n\trender?: Render,\n): NeepNode[] {\n\tif (Array.isArray(node)) { return node; }\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\tif (!iRender.isNode(node) && typeof node === 'object' && render) {\n\t\tnode = render(node, context, auxiliary);\n\t}\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\treturn [{\n\t\t[isElementSymbol]: true,\n\t\ttag: Tags.Value,\n\t\tvalue: node,\n\t\tchildren: [],\n\t}];\n}\n\n\nexport default function normalize(\n\tnObject: Entity,\n\tresult: any,\n) {\n\treturn exec(\n\t\tnObject,\n\t\tnObject.delivered,\n\t\trenderNode(\n\t\t\tnObject.iRender,\n\t\t\tresult,\n\t\t\tnObject.context,\n\t\t\tnObject.component[renderSymbol],\n\t\t),\n\t\tnObject.context.slots,\n\t\tBoolean(nObject.native),\n\t);\n}\n","import NeepObject from \"./Object\";\n\nlet delayedRefresh = 0;\nconst objectSet = new Set<NeepObject>();\nexport function wait(obj: NeepObject) {\n\tif (delayedRefresh <= 0) { return false; }\n\tobjectSet.add(obj);\n\treturn true;\n}\nfunction run() {\n\tif (delayedRefresh > 0) { return; }\n\tconst list = [...objectSet];\n\tobjectSet.clear();\n\tlist.forEach(o => o.refresh());\n}\nasync function asyncRefresh<T>(f: () => PromiseLike<T> | T): Promise<T> {\n\ttry {\n\t\tdelayedRefresh++;\n\t\treturn await f();\n\t} finally {\n\t\tdelayedRefresh--;\n\t\trun();\n\t}\n}\nexport default function refresh<T>(f: () => T, async?: false): T;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync: true,\n): Promise<T>;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync?: boolean,\n): PromiseLike<T> | T;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync?: boolean,\n): PromiseLike<T> | T {\n\tif (async) { return asyncRefresh(f); }\n\ttry {\n\t\tdelayedRefresh++;\n\t\treturn f();\n\t} finally {\n\t\tdelayedRefresh--;\n\t\trun();\n\t}\n}","import {\n\tExposed, Delivered,\n\tEntity as ComponentEntity,\n\tNativeComponent,\n\tHook, Hooks, NeepNode, IRender,\n} from '../type';\nimport { callHook, setHook } from '../hook';\nimport { MountedNode } from './draw';\nimport Container from './Container';\nimport convert, { TreeNode } from './convert';\nimport { wait } from './refresh';\n\nfunction createExposed(obj: NeepObject): Exposed {\n\tconst cfg: { [K in Exclude<keyof Exposed, '$label'>]-?:\n\t\t{ configurable: true, value: Exposed[K] }\n\t\t| { configurable: true, get(): Exposed[K] }\n\t} = {\n\t\t$parent: { configurable: true, get: () => obj.parent?.exposed },\n\t\t$component: { configurable: true, value: null },\n\t\t$isContainer: { configurable: true, value: false },\n\t\t$created: { configurable: true, get: () => obj.created },\n\t\t$destroyed: { configurable: true, get: () => obj.destroyed },\n\t\t$mounted: { configurable: true, get: () => obj.mounted },\n\t\t$unmounted: { configurable: true, get: () => obj.unmounted },\n\t};\n\tconst exposed: Exposed = Object.create(null, cfg);\n\treturn exposed;\n}\n\nfunction createEntity(obj: NeepObject): ComponentEntity {\n\tconst cfg: { [K in keyof ComponentEntity]-?:\n\t\t{ configurable: true, value: ComponentEntity[K], writable?: boolean }\n\t\t| { configurable: true, get(): ComponentEntity[K] }\n\t} = {\n\t\texposed: { configurable: true, get: () => obj.exposed },\n\t\tdelivered: { configurable: true, get: () => obj.delivered },\n\t\tparent: { configurable: true, get: () => obj.parent?.entity },\n\t\tcomponent: { configurable: true, value: null },\n\t\tisContainer: { configurable: true, value: false },\n\t\tcreated: { configurable: true, get: () => obj.created },\n\t\tdestroyed: { configurable: true, get: () => obj.destroyed },\n\t\tmounted: { configurable: true, get: () => obj.mounted },\n\t\tunmounted: { configurable: true, get: () => obj.unmounted },\n\t\t$_hooks: { configurable: true, value: Object.create(null) },\n\t\t$_valueIndex: { configurable: true, value: 0, writable: true },\n\t\t$_values: { configurable: true, value: [] },\n\t\tcallHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(h: string) { callHook(h, entity); },\n\t\t},\n\t\tsetHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(id: string, hook: Hook) {\n\t\t\t\treturn setHook(id, hook, entity);\n\t\t\t},\n\t\t},\n\t\trefresh: {\n\t\t\tconfigurable: true,\n\t\t\tvalue: obj.refresh.bind(obj),\n\t\t},\n\t};\n\tconst entity: ComponentEntity = Object.create(null, cfg);\n\treturn entity;\n}\n\nexport default class NeepObject {\n\treadonly iRender: IRender;\n\t/** 接受到的呈递值 */\n\treadonly parentDelivered: Delivered;\n\t/** 向后代呈递的值 */\n\treadonly delivered: Delivered;\n\t/** 组件暴露值 */\n\treadonly exposed: Exposed = createExposed(this);\n\t/** 组件实体 */\n\treadonly entity: ComponentEntity = createEntity(this);\n\t/** 父组件 */\n\tparent?: NeepObject;\n\t/** 原生组件 */\n\tnative: NativeComponent | undefined;\n\t/** 状态 */\n\tcreated: boolean = false;\n\tdestroyed: boolean = false;\n\tmounted: boolean = false;\n\tunmounted: boolean = false;\n\t/**  子组件的暴露值 */\n\treadonly children: Set<Exposed> = new Set();\n\t/** The subtree mounted on the parent node */\n\ttree: (MountedNode | MountedNode[])[] = [];\n\treadonly container: Container;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tparent?: NeepObject,\n\t\tdelivered: Delivered = parent?.delivered || Object.create(null),\n\t\tcontainer?: Container,\n\t) {\n\t\tthis.iRender = iRender;\n\t\tthis.parentDelivered = delivered;\n\t\tthis.delivered = Object.create(delivered);\n\t\tif (parent) {\n\t\t\tthis.parent = parent;\n\t\t}\n\t\tthis.container = container || this as any as Container;\n\t}\n\t/** 结果渲染函数 */\n\tprotected _render: () => NeepNode[] = () => [];\n\n\tget canRefresh(): boolean {\n\t\tif (wait(this)) { return false; }\n\t\treturn !this._delayedRefresh;\n\t}\n\tprotected get needRefresh(): boolean {\n\t\tif (wait(this)) { return false; }\n\t\tif (this._delayedRefresh) { return false; }\n\t\tconst needRefresh = this._needRefresh;\n\t\tthis._needRefresh = false;\n\t\treturn needRefresh;\n\t}\n\t/** 是否需要继续刷新 */\n\tprotected _needRefresh = false;\n\tprivate _delayedRefresh = 0;\n\t/** 是否为刷新中 */\n\tprivate _refreshing = false;\n\t/** 渲染结果 */\n\tprotected _nodes: (TreeNode | TreeNode[])[] = [];\n\tprotected _refresh() { }\n\tasync asyncRefresh<T>(f: () => PromiseLike<T> | T): Promise<T> {\n\t\ttry {\n\t\t\tthis._delayedRefresh++;\n\t\t\treturn await f();\n\t\t} finally {\n\t\t\tthis._delayedRefresh--;\n\t\t\tthis.refresh();\n\t\t}\n\t}\n\trefresh(): void;\n\trefresh<T>(f: () => T, async?: false): T;\n\trefresh<T>(f: () => PromiseLike<T> | T, async: true): Promise<T>;\n\trefresh<T>(\n\t\tf: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T;\n\trefresh<T>(\n\t\tf?: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T | undefined;\n\trefresh<T>(\n\t\tf?: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T | undefined {\n\t\tif (typeof f === 'function') {\n\t\t\tif (async) { return this.asyncRefresh(f); }\n\t\t\ttry {\n\t\t\t\tthis._delayedRefresh++;\n\t\t\t\treturn f();\n\t\t\t} finally {\n\t\t\t\tthis._delayedRefresh--;\n\t\t\t\tif (this._delayedRefresh <= 0) {\n\t\t\t\t\tthis.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.destroyed) { return; }\n\t\tthis._needRefresh = true;\n\t\tif (!this.created) { return; }\n\n\t\tif (this._refreshing) { return; }\n\t\tthis._refreshing = true;\n\n\t\tlet nodes: NeepNode[] | undefined;\n\t\twhile(this.needRefresh) {\n\t\t\tnodes = this._render();\n\t\t\tif (this.destroyed) { return; }\n\t\t}\n\t\tthis._refreshing = false;\n\t\tif (!this.canRefresh) { return; }\n\t\tif (!nodes) { return; }\n\n\t\tthis._nodes = convert(this, nodes, this._nodes);\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tif (this.unmounted) { return; }\n\t\tthis._refresh();\n\t}\n\tcallHook<H extends Hooks>(id: H): void;\n\tcallHook(id: string): void;\n\tcallHook(id: string): void {\n\t\tcallHook(id, this.entity);\n\t}\n\n\tchildNodes: any[] = [];\n\t/** 更新属性及子代 */\n\tprotected _update(props: object, children: any[]): void {\n\t\tthis.childNodes = children;\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: object, children: any[]): void {\n\t\tthis._update(props, children);\n\t}\n\n\n\tprivate __executed_destroy = false;\n\tprivate __executed_mount = false;\n\tprivate __executed_mounted = false;\n\tprotected _destroy() { }\n\tdestroy() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis.__executed_destroy = true;\n\t\tthis.callHook('beforeDestroy');\n\t\tthis._destroy();\n\t\tthis.callHook('destroyed');\n\t\tthis.destroyed = true;\n\t}\n\tprotected _mount() { }\n\tmount() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tif (this.__executed_mount) { return; }\n\t\tthis.__executed_mount = true;\n\t\tthis.callHook('beforeMount');\n\t\tthis._mount();\n\t\tthis.callHook('mounted');\n\t\tthis.mounted = true;\n\t}\n\tprotected _unmount() { }\n\tunmount() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.__executed_mounted) { return; }\n\t\tthis.__executed_mounted = true;\n\t\tthis.callHook('beforeUnmount');\n\t\tthis._unmount();\n\t\tthis.callHook('unmounted');\n\t\tthis.unmounted = true;\n\t}\n\t_draw() {}\n\tdraw() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis.callHook('beforeUpdate');\n\t\tthis._draw();\n\t\tthis.callHook('updated');\n\t}\n}\n","import { Component, NeepNode, Slots, Context, Delivered, NativeShadow } from '../type';\nimport auxiliary, { createElement, Value } from '../auxiliary';\nimport { monitorable } from '../install';\nimport { setCurrent } from '../helper/current';\nimport convert, { destroy, TreeNode } from './convert';\nimport draw, { unmount, MountedNode, getNodes } from './draw';\nimport normalize from './normalize';\nimport { getSlots, setSlots } from './slot';\nimport NeepObject from './Object';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\nimport { typeSymbol } from '../symbols';\n\nfunction update(\n\tnObject: Entity<any, any>,\n\tprops: any,\n\tchildren:any[],\n) {\n\tupdateProps(nObject.props, props);\n\n\tconst slots = Object.create(null);\n\tconst {\n\t\tnative,\n\t\tiRender,\n\t} = nObject;\n\tconst childNodes = getSlots(\n\t\tiRender,\n\t\tchildren,\n\t\tslots,\n\t\tBoolean(native),\n\t);\n\tsetSlots(slots, nObject.slots);\n\tif (!native) { return; }\n\tnObject.nativeNodes\n\t\t= convert(nObject, childNodes, nObject.nativeNodes);\n\tif (!nObject.mounted) { return; }\n\tnObject.container.markDraw(nObject);\n}\n\nfunction createContext<\n\tP extends object = object,\n\tR extends object = object\n>(nObject: Entity<P, R>): Context {\n\treturn initContext({\n\t\tslots: nObject.slots,\n\t\tget created() { return nObject.created; },\n\t\tget parent() { return nObject.parent.exposed; },\n\t\tget delivered() { return nObject.parentDelivered; },\n\t\tget children() { return nObject.children; },\n\t\tget childNodes() { return nObject.childNodes; },\n\t\trefresh(f) { nObject.refresh(f); }\n\t}, nObject.exposed);\n}\n\n/** 初始化渲染 */\nfunction initRender<R extends object = object>(\n\tnObject: Entity<any, R>\n): { render(): any, nodes: any, stopRender(): void } {\n\tconst {\n\t\tcomponent,\n\t\tprops,\n\t\tcontext,\n\t\tentity,\n\t} = nObject;\n\tconst refresh = (changed: boolean) => changed && nObject.refresh()\n\t// 初始化执行\n\tconst result = monitorable.exec(() => setCurrent(\n\t\t() => component(props, context, auxiliary),\n\t\tentity,\n\t), refresh, { resultOnly: true, postpone: true });\n\tif (typeof result === 'function') {\n\t\t// 响应式\n\t\tconst render = monitorable.createExecutable(\n\t\t\t() => normalize(nObject, (result as () => NeepNode)()),\n\t\t\trefresh,\n\t\t);\n\t\treturn {\n\t\t\tnodes: render(),\n\t\t\trender,\n\t\t\tstopRender: () => render.stop(),\n\t\t};\n\t}\n\n\tconst render = monitorable.createExecutable(\n\t\t() => normalize(nObject, setCurrent(\n\t\t\t() => component(props, context, auxiliary),\n\t\t\tentity,\n\t\t)),\n\t\trefresh,\n\t\t{ postpone: true },\n\t);\n\treturn {\n\t\tnodes: monitorable.exec(\n\t\t\t() => normalize(nObject, result),\n\t\t\trefresh,\n\t\t\t{ resultOnly: true, postpone: true },\n\t\t),\n\t\trender,\n\t\tstopRender: () => render.stop(),\n\t};\n}\n\n\nexport default class Entity<\n\tP extends object = object,\n\tR extends object = object\n> extends NeepObject {\n\t/** 组件函数 */\n\treadonly component: Component<P, R>;\n\t/** 组件属性 */\n\treadonly props: P = monitorable.encase(Object.create(null));\n\t/** 组件槽 */\n\treadonly slots: Slots = monitorable.encase(Object.create(null));\n\t/** 结果渲染函数 */\n\tprivate readonly _stopRender:() => void;\n\t/** 原生子代 */\n\tnativeNodes: (TreeNode | TreeNode[])[] | undefined;\n\tshadowTree: (MountedNode | MountedNode[])[] = [];\n\tnativeTree: (MountedNode | MountedNode[])[] = [];\n\tprivate readonly _shadow: NativeShadow | undefined;\n\t/** 组件上下文 */\n\treadonly context: Context;\n\treadonly parent: NeepObject;\n\t/** 结果渲染函数 */\n\tconstructor(\n\t\tcomponent: Component<P, R>,\n\t\tprops: object,\n\t\tchildren: any[],\n\t\tparent: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(parent.iRender, parent, delivered, parent.container);\n\t\tthis.component = component;\n\t\tReflect.defineProperty(\n\t\t\tthis.exposed,\n\t\t\t'$component',\n\t\t\t{ value: component, enumerable: true, configurable: true },\n\t\t);\n\t\t// 原生组件\n\t\t[this.native, this._shadow] =\n\t\t\tcomponent[typeSymbol] === 'native' &&\n\t\t\tthis.iRender.component?.() || [];\n\t\t// 父子关系\n\t\tthis.parent = parent;\n\t\tparent.children.add(this.exposed);\n\t\t// 上下文属性\n\t\tconst context = createContext(this);\n\t\tthis.context = context;\n\t\t// 初始化钩子\n\t\tthis.callHook('beforeCreate');\n\t\t// 更新属性\n\t\tthis.childNodes = children;\n\t\tupdate(this, props, children);\n\t\t// 获取渲染函数及初始渲染\n\t\tconst { render, nodes, stopRender } = initRender(this);\n\t\tthis._render = render;\n\t\tthis._stopRender = stopRender;\n\t\tthis._nodes = convert(this, nodes);\n\t\t// 初始化钩子\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t\tif (this._needRefresh) { this.refresh(); }\n\t}\n\t/** 更新属性及子代 */\n\t_update(props: object, children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\tupdate(this, props, children);\n\t}\n\t_destroy() {\n\t\tif (this._stopRender) {\n\t\t\tthis._stopRender();\n\t\t}\n\t\tthis.parent.children.delete(this.exposed);\n\t\tdestroy(this._nodes);\n\t}\n\n\t/** 刷新 */\n\t_refresh() {\n\t\tthis.container.markDraw(this);\n\t}\n\t_draw() {\n\t\tconst {nativeNodes, iRender, _shadow, native} = this;\n\t\tif (!native || !nativeNodes || !_shadow) {\n\t\t\tthis.tree = draw(\n\t\t\t\tiRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.tree,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tthis.shadowTree = draw(\n\t\t\tiRender,\n\t\t\tthis._nodes,\n\t\t\tthis.shadowTree,\n\t\t);\n\t\tconsole.log(nativeNodes);\n\t\tthis.nativeTree = draw(\n\t\t\tiRender,\n\t\t\tnativeNodes,\n\t\t\tthis.nativeTree,\n\t\t);\n\t}\n\t_mount() {\n\t\tconst {nativeNodes, iRender, _shadow, native, _nodes} = this;\n\t\tif (!native || !nativeNodes || !_shadow) {\n\t\t\tthis.tree = draw(iRender, _nodes);\n\t\t\treturn;\n\t\t}\n\t\tthis.tree = draw(iRender, convert(this, native));\n\t\tthis.shadowTree = draw(iRender, _nodes);\n\t\tfor (const it of getNodes(this.shadowTree)) {\n\t\t\tiRender.insert(_shadow, it);\n\t\t}\n\t\tthis.nativeTree = draw(iRender, nativeNodes);\n\t\tfor (const it of getNodes(this.nativeTree)) {\n\t\t\tiRender.insert(native, it);\n\t\t}\n\t}\n\t_unmount() {\n\t\tconst {iRender, nativeTree} = this;\n\t\tunmount(iRender, this.tree);\n\t\tif (!nativeTree) { return; }\n\t\tunmount(iRender, nativeTree);\n\t}\n}\n","import { getRender } from '../install';\nimport { NeepNode, NeepElement, Tag } from '../type';\nimport { Tags, isElement, Value, Template } from '../auxiliary';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport { recursive2iterable } from './recursive';\nimport Entity from './Entity';\nimport NeepObject from './Object';\nimport Container from './Container';\nimport { updateProps } from './props';\n\nexport interface TreeNode\n\textends Omit<\n\t\tNeepElement,\n\t\t'children' | 'tag' | typeof isElementSymbol\n\t>\n{\n\t/** 标签名 */\n\ttag: Tag;\n\tchildren: (this | this[])[];\n\tmounted?: boolean;\n\tcomponent?: NeepObject;\n}\n/** 强制转换为 NeepElement */\nfunction toElement(t: any): null | NeepElement {\n\tif (t === false || t === null || t === undefined) {\n\t\treturn null;\n\t}\n\tif (isElement(t)) {\n\t\treturn t;\n\t}\n\treturn {\n\t\t[isElementSymbol]: true,\n\t\ttag: Value,\n\t\tkey: t,\n\t\tvalue: t,\n\t\tchildren: [],\n\t};\n}\n\nexport function destroy(\n\ttree: TreeNode | TreeNode[] | (TreeNode | TreeNode[])[]\n) {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(t => destroy(t));\n\t\treturn;\n\t}\n\tconst { component } = tree;\n\tif (component) { component.destroy(); }\n}\n\nfunction createItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n): TreeNode {\n\tif (!source) { return { tag: null, children: [] }; }\n\tconst { tag } = source;\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(nObject, source.children),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Entity(\n\t\t\t\ttag,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Container(\n\t\t\t\tiRender,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\treturn {\n\t\t\t...source,\n\t\t\tchildren: convert(nObject, source.children),\n\t\t};\n\t}\n\treturn {...source, children: convert(nObject, source.children) };\n}\n\n/**\n * 更新树节点\n * @param nObject Neep 对象\n * @param source 用于替换的源\n * @param tree 已有树\n */\nfunction updateList(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: TreeNode | TreeNode[],\n): TreeNode[] {\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: TreeNode[] = [];\n\tfor (const src of recursive2iterable(source)) {\n\t\tconst node = toElement(src);\n\t\tif (!node) { continue; }\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === node.tag && it.key === node.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tnewList.push(updateItem(nObject, node, tree[index]));\n\t\t\ttree.splice(index, 1);\n\t\t} else {\n\t\t\tnewList.push(createItem(nObject, node));\n\t\t}\n\t}\n\tdestroy(tree);\n\treturn newList;\n}\n\n/**\n * 更新树节点\n * @param tree 已有树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n */\nfunction updateItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n\ttree?: TreeNode | TreeNode[],\n): TreeNode {\n\tif (!tree) {\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!source) {\n\t\tdestroy(tree);\n\t\treturn { tag: null, children: [] };\n\t}\n\tif (Array.isArray(tree)) {\n\t\tif (!tree.length) { return createItem(nObject, source); }\n\t\tconst index = tree.findIndex(it => it.tag === source.tag);\n\t\tif (index < 0) {\n\t\t\tdestroy(tree);\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tdestroy(all);\n\t}\n\tconst { tag } = source;\n\tif (tag !== tree.tag) {\n\t\tdestroy(tree);\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(\n\t\t\t\t\tnObject,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tcomponent!.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\tif (iRender !== component.iRender) {\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tcomponent!.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\tlet delivered: any;\n\t\tif (Tags.Deliver === tag) {\n\t\t\tconst props = { ...source.props };\n\t\t\tdelete props.ref;\n\t\t\tdelete props.slot;\n\t\t\tdelete props.key;\n\t\t\tdelivered = updateProps(\n\t\t\t\ttree.$__neep__delivered,\n\t\t\t\tprops,\n\t\t\t\ttree.props,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t\treturn {\n\t\t\t...source,\n\t\t\t$__neep__delivered: delivered,\n\t\t\tchildren: convert(\n\t\t\t\tnObject,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t};\n\t}\n\treturn {\n\t\t...source,\n\t\tchildren: convert(nObject, source.children, tree.children),\n\t};\n}\n\n\nfunction createAll(\n\tnObject: NeepObject,\n\tsource: any[],\n): (TreeNode | TreeNode[])[] {\n\tif (!source.length) { return []; }\n\treturn (source as any[]).map(item => {\n\t\tif (!Array.isArray(item)) {\n\t\t\treturn createItem(nObject, toElement(item));\n\t\t}\n\t\treturn [...recursive2iterable(item)]\n\t\t\t.map(it => createItem(nObject, toElement(it)));\n\t});\n}\nfunction *updateAll(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: (TreeNode | TreeNode[])[],\n): Iterable<TreeNode | TreeNode[]> {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length);\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tyield updateList(nObject, src, tree[index]);\n\t\t} else {\n\t\t\tyield updateItem(nObject, toElement(src), tree[index]);\n\t\t}\n\t}\n\tlength = Math.max(source.length, source.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tdestroy(tree[index]);\n\t\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = toElement(source[index]);\n\t\t\tif (Array.isArray(src)) {\n\t\t\t\tyield [...recursive2iterable(src)]\n\t\t\t\t\t.map(it => createItem(nObject, it));\n\t\t\t} else {\n\t\t\t\tyield createItem(nObject, src);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * 更新树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n * @param tree 已有树\n */\nfunction convert(\n\tnObject: NeepObject,\n\tsource: any,\n\ttree?: (TreeNode | TreeNode[])[],\n): (TreeNode | TreeNode[])[] {\n\tif (!Array.isArray(source)) { source = [source]; }\n\tif (!tree) {\n\t\treturn createAll(nObject, source);\n\t}\n\treturn [...updateAll(nObject, source, tree)];\n}\n\n\nexport default convert;\n","import {\n\tIRender,\n\tMountProps,\n\tNativeNode,\n\tNativeContainer,\n\tDelivered,\n} from '../type';\nimport { Tags } from '../auxiliary';\nimport { createMountedNode } from './id';\nimport convert, { destroy } from './convert';\nimport draw, { unmount, getNodes, MountedNode } from './draw';\nimport NeepObject from './Object';\nimport { nextFrame } from '../install';\n\n\nlet awaitDraw = new Set<Container>();\nlet requested = false;\nfunction markDraw(c: Container) {\n\tawaitDraw.add(c);\n\tif (requested) { return; }\n\trequested = true;\n\tnextFrame(() => {\n\t\trequested = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tlist.map(c => c.drawAll());\n\t});\n}\n\nexport default class Container extends NeepObject {\n\tprops: MountProps;\n\t/** 组件树结构 */\n\tcontent: (MountedNode | MountedNode[])[] = [];\n\t_node: NativeNode | null = null;\n\t_container: NativeContainer | null = null;\n\treadonly rootContainer: Container = this;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tprops: MountProps,\n\t\tchildren: any[],\n\t\tparent?: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(iRender, parent, delivered);\n\t\tthis.props = props;\n\t\tthis.parent = parent;\n\t\tif (parent) {\n\t\t\tthis.rootContainer = parent.container.rootContainer;\n\t\t}\n\t\tthis.callHook('beforeCreate');\n\t\tthis._render = () => children;\n\t\tthis._nodes = convert(this, children);\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t}\n\t_drawChildren = false;\n\t_drawContainer = false;\n\tsetChildren(children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\tthis._render = () => children;\n\t\tthis._drawChildren = true;\n\t\tthis.refresh();\n\t}\n\tsetProps(props: MountProps): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.props = props;\n\t\tthis._drawContainer = true;\n\t\tthis.refresh();\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: MountProps, children: any[]): void {\n\t\tthis.refresh(() => {\n\t\t\tthis.setProps(props);\n\t\t\tthis.setChildren(children);\n\t\t});\n\t}\n\t_refresh() {\n\t\tthis.markDraw(this);\n\t}\n\t_mount() {\n\t\tconst { props, parent, iRender } = this;\n\t\tconst content = draw(this.container.iRender, this._nodes);\n\t\tthis.content = content;\n\t\tconst [container, node]\n\t\t\t= iRender.mount(props, parent?.iRender);\n\t\tfor (const it of getNodes(content)) {\n\t\t\tiRender.insert(container, it);\n\t\t}\n\t\tthis.tree = [createMountedNode({\n\t\t\ttag: Tags.Value,\n\t\t\tcomponent: undefined,\n\t\t\tnode,\n\t\t\tvalue: node,\n\t\t\tchildren: [],\n\t\t})];\n\t\tthis._node = node;\n\t\tthis._container = container;\n\t}\n\t_destroy() {\n\t\tdestroy(this.content);\n\t}\n\t_unmount() {\n\t\tconst { parent, iRender } = this;\n\t\tif (parent) {\n\t\t\tunmount(parent.iRender, this.tree);\n\t\t}\n\t\tiRender.unmount(\n\t\t\tthis._container!,\n\t\t\tthis._node!,\n\t\t\tBoolean(parent),\n\t\t);\n\t\tunmount(this.iRender, this.content);\n\t}\n\t_draw() {\n\t}\n\tdrawSelf() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tconst {\n\t\t\t_drawChildren: drawChildren,\n\t\t\t_drawContainer: drawContainer,\n\t\t} = this;\n\t\tthis._needDraw = false;\n\t\tthis._drawChildren = false;\n\t\tthis._drawContainer = false;\n\t\tthis.callHook('beforeUpdate');\n\t\tif (drawContainer) {\n\t\t\tthis.iRender.drawContainer(\n\t\t\t\tthis._container!,\n\t\t\t\tthis._node!,\n\t\t\t\tthis.props,\n\t\t\t\tthis.parent?.iRender,\n\t\t\t);\n\t\t}\n\t\tif (drawChildren) {\n\t\t\tthis.content = draw(\n\t\t\t\tthis.iRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.content,\n\t\t\t);\n\t\t}\n\t\tthis.callHook('updated');\n\t}\n\t/** 等待重画的项目 */\n\tprivate _awaitDraw = new Set<NeepObject>();\n\t/** 自身是否需要重绘 */\n\tprivate _needDraw = false;\n\t/** 标记需要绘制的元素 */\n\tmarkDraw(\n\t\tnObject: NeepObject,\n\t\tremove = false,\n\t) {\n\t\tif (nObject === this) {\n\t\t\tthis._needDraw = !remove;\n\t\t} else if (remove) {\n\t\t\tthis._awaitDraw.delete(nObject);\n\t\t} else {\n\t\t\tthis._awaitDraw.add(nObject);\n\t\t}\n\t\tthis.rootContainer.markDrawContainer(\n\t\t\tthis,\n\t\t\t!this._needDraw && !this._awaitDraw.size || this.destroyed,\n\t\t);\n\t}\n\tdrawContainer() {\n\t\tconst {\n\t\t\t_node: node,\n\t\t\t_container: container,\n\t\t\t_awaitDraw: awaitDraw,\n\t\t} = this;\n\t\tif (!node || !container) { return; }\n\t\tthis.callHook('beforeDraw');\n\t\tconst needDraw = this._needDraw;\n\t\tthis._needDraw = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tif (needDraw) { this.drawSelf(); }\n\t\tlist.map(c => c.draw());\n\t\tthis.iRender.draw(container, node);\n\t\tthis.callHook('drawn');\n\t}\n\tprivate _containers = new Set<Container>();\n\tmarkDrawContainer(\n\t\tcontainer: Container,\n\t\tremove = false,\n\t) {\n\t\tif (remove) {\n\t\t\tthis._containers.delete(container);\n\t\t} else {\n\t\t\tthis._containers.add(container);\n\t\t}\n\t\tmarkDraw(this);\n\t}\n\tdrawAll() {\n\t\tconst containers = this._containers;\n\t\tif (!containers.size) { return; }\n\t\tthis.callHook('beforeDrawAll');\n\t\tconst list = [...containers];\n\t\tlist.map(c => c.drawContainer());\n\t\tthis.callHook('drawnAll');\n\t}\n}\n","import {\n\tMountProps,\n\tNeepElement,\n\tComponent,\n\tRootExposed,\n} from '../type';\nimport { isElement, createElement } from '../auxiliary';\nimport { isProduction } from '../constant';\nimport { devtools, getRender } from '../install';\nimport Container from './Container';\n\nexport function render(\n\te?: NeepElement | Component,\n\tp: MountProps = {},\n): RootExposed {\n\tlet params = {...p};\n\tconst container =  new Container(\n\t\tgetRender(p.type),\n\t\tparams,\n\t\te === undefined ? [] : isElement(e) ? [e] : [createElement(e)],\n\t);\n\tif (!isProduction) {\n\t\tdevtools.renderHook(container);\n\t}\n\tconst { exposed } = container;\n\tReflect.defineProperty(exposed, '$update', {\n\t\tvalue(c?: NeepElement | Component) {\n\t\t\tcontainer.setChildren(c === undefined ? []\n\t\t\t\t: isElement(c) ? [c] : [createElement(c)]);\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$mount', {\n\t\tvalue(target?: any) {\n\t\t\tif (exposed.$mounted) { return exposed; }\n\t\t\tif (target) {\n\t\t\t\tparams.target = target;\n\t\t\t\tcontainer.setProps(params);\n\t\t\t}\n\t\t\tcontainer.mount();\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$unmount', {\n\t\tvalue() {\n\t\t\tif (!exposed.$mounted) { return; }\n\t\t\tif (exposed.$unmounted) { return; }\n\t\t\tif (exposed.$destroyed) { return container.destroy(); }\n\t\t\tcontainer.unmount();\n\t\t\treturn;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tif (params.target) {\n\t\tcontainer.mount();\n\t}\n\treturn exposed as any as RootExposed;\n}\nexport { default as refresh } from './refresh';\n","import { Component, Render, Marks } from './type';\nimport { nameSymbol, typeSymbol, renderSymbol } from './symbols';\n\n/** 组件标记函数 */\nexport interface Mark {\n\t<N extends Component<any, any>>(component: N): N;\n}\n\n/**\n * 创建组件标记函数\n */\nfunction Mark<S extends keyof Marks>(\n\tsymbol: S,\n\tvalue: Component[S],\n): Mark {\n\treturn component => {\n\t\tcomponent[symbol] = value as any;\n\t\treturn component;\n\t};\n}\n\n\n/** 标记组件名称 */\nexport function mName(name: string): Mark;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent: N,\n): N;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(nameSymbol, name); }\n\tcomponent[nameSymbol] = name;\n\treturn component;\n}\n\n/** 标记组件类型 */\nexport function mType(type?: 'native' | 'simple' | 'standard'): Mark;\nexport function mType<N extends Component<any, any>>(\n\ttype: 'native' | 'simple' | 'standard',\n\tcomponent: N,\n): N;\nexport function mType<N extends Component<any, any>>(\n\ttype?: 'native' | 'simple' | 'standard',\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, type); }\n\tcomponent[typeSymbol] = type;\n\treturn component;\n}\n/** 标记为简单组件 */\nexport function mSimple(): Mark;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'simple'); }\n\tcomponent[typeSymbol] = 'simple';\n\treturn component;\n}\n/** 标记为原生组件 */\nexport function mNative(): Mark;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'native'); }\n\tcomponent[typeSymbol] = 'native';\n\treturn component;\n}\n\n/** 标记独立的渲染函数 */\nexport function mRender(fn?: Marks[typeof renderSymbol]): Mark;\nexport function mRender<N extends Component<any, any>>(\n\tfn: Marks[typeof renderSymbol] | undefined,\n\tcomponent: N,\n): N;\nexport function mRender<N extends Component<any, any>>(\n\tfn?: Marks[typeof renderSymbol] | undefined,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(renderSymbol, fn); }\n\tcomponent[renderSymbol] = fn;\n\treturn component;\n}\n\nexport function create<P extends object>(\n\tc: Component<P, never>,\n): Component<P, never>;\nexport function create<\n\tP extends object = object,\n\tR extends object = object,\n>(c: Component<P, R>, r: Render<R>): Component<P, R>;\nexport function create<T extends Component<any, any>>(\n\tc: T,\n\tr?: Render,\n): T {\n\tif (typeof r === 'function') {\n\t\tc[renderSymbol] = r;\n\t}\n\treturn c;\n}\n\nexport function mark<N extends Component<any, any>>(\n\tcomponent: N,\n\t...marks: Mark[]\n): N {\n\tfor (const m of marks) { m(component); }\n\treturn component;\n}\n"],"names":["version","mode","isProduction","NeepError","Error","constructor","message","tag","monitorable","value","computed","isValue","encase","recover","nextFrameApi","nextFrame","fn","v","assert","renders","Object","create","getRender","type","default","addRender","render","install","apis","api","Array","isArray","installRender","ScopeSlot","SlotRender","Slot","Value","Container","Deliver","Template","Fragment","current","setCurrent","entity","oldEntity","$_valueIndex","ret","$_values","length","checkCurrent","name","initOnly","created","constructors","initContext","context","exposed","addContextConstructor","push","safeify","hooks","setHook","id","hook","list","$_hooks","set","Set","add","delete","callHook","watch","cb","stop","s","useValue","index","values","undefined","setValue","obj","opt","includes","Reflect","defineProperty","get","configurable","enumerable","expose","deliver","delivered","isElementSymbol","Symbol","for","typeSymbol","nameSymbol","renderSymbol","isElement","createElement","attrs","children","node","key","slot","ref","Tags","argv","args","props","on","k","onInfo","exec","elements","n","concat","simple","label","text","color","auxiliary","Life","Element","Dev","Constant","State","setAuxiliary","defineAuxiliary","createMountedNode","recursive2iterable","it","getLastNode","tree","component","getFirstNode","getNodes","unmount","iRender","forEach","e","remove","replace","newTree","oldTree","next","parent","insert","updateList","source","createItem","newList","mountedMap","Map","src","findIndex","old","item","updateItem","splice","size","last","filter","t","has","i","o","updateAll","Math","min","max","createList","all","draw","createValue","substr","update","createAll","isNode","RegExp","String","Date","toISOString","placeholder","map","mount","getSlots","slots","native","nativeList","ownKeys","el","renderSlots","createSlots","inserted","setSlots","updateProps","oldProps","define","newKeys","nObject","newDelivered","$__neep__delivered","container","slotMap","childNodes","refresh","f","result","nodes","renderNode","execSimple","execSlot","normalize","Boolean","delayedRefresh","objectSet","wait","run","clear","async","asyncRefresh","NeepObject","cfg","$parent","_obj$parent","$component","$isContainer","$created","$destroyed","destroyed","$mounted","mounted","$unmounted","unmounted","createExposed","this","_obj$parent2","isContainer","writable","h","bind","createEntity","parentDelivered","_delayedRefresh","needRefresh","_needRefresh","_refresh","_refreshing","_render","canRefresh","_nodes","convert","_update","_destroy","destroy","__executed_destroy","_mount","__executed_mount","_unmount","__executed_mounted","_draw","nativeNodes","markDraw","Entity","_shadow","_this$iRender$compone","stopRender","changed","resultOnly","postpone","createExecutable","initRender","_stopRender","shadowTree","console","log","nativeTree","toElement","_source$props","_source$props2","awaitDraw","requested","rootContainer","setChildren","_drawChildren","setProps","_drawContainer","content","_node","_container","drawSelf","drawChildren","drawContainer","_needDraw","_this$parent","_awaitDraw","markDrawContainer","needDraw","c","_containers","drawAll","containers","p","params","target","Mark","symbol","mName","mType","mSimple","mNative","mRender","r","mark","marks","m"],"mappings":"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"}