{"version":3,"file":"neep.core.esm.min.js","sources":["../src/constant.ts","../src/EventEmitter.ts","../src/Error.ts","../src/install.ts","../src/register.ts","../src/symbols.ts","../src/create.ts","../src/components/lazy.ts","../src/auxiliary/tags.ts","../src/helper/current.ts","../src/helper/context.ts","../src/hook.ts","../src/auxiliary/life.ts","../src/auxiliary/element.ts","../src/auxiliary/dev.ts","../src/auxiliary/index.ts","../src/render/id.ts","../src/render/recursive.ts","../src/render/draw.ts","../src/render/slot.ts","../src/render/props.ts","../src/render/normalize.ts","../src/render/refresh.ts","../src/render/Object.ts","../src/render/Entity.ts","../src/render/convert.ts","../src/render/Container.ts","../src/render/index.ts"],"sourcesContent":["/**\n * Global constant\n *\n * Will be replaced by the 'rollup-plugin-replace' plug-in\n */\n\n /**\n * Neep code version\n */\nexport const version = '__VERSION__' as string;\n/**\n * Current mode\n * @enum production\n * @enum development\n */\nexport const mode = '__MODE__' as any as 'production' | 'development';\n/**\n * Is the current mode production mode\n * @description Support tree shaking\n */\nexport const isProduction = mode === 'production';\n","import { monitorable } from './install';\nimport { Emit, On } from './type';\n\nfunction getEventName(k: string): string {\n\tif (k[0] === '@') { return k.substr(1); }\n\tif (/^on[:-]/.test(k)) { return k.substr(3); }\n\tif (/^n([:-])on(\\1|:)/.test(k)) { return k.substr(5); }\n\treturn '';\n}\ninterface AddEvent<T extends Record<string, any[]>> {\n\t<N extends keyof T>(\n\t\tentName: N,\n\t\tlistener: (...p: T[N]) => void,\n\t): void\n}\n\nfunction addEventFromCollection(\n\taddEvent:(entName: string, listener: (...p: any) => void) => void,\n\tevents: any,\n) {\n\tif (!events) { return; }\n\tif (typeof events === 'function') {\n\t\tconst { names } = events as Emit;\n\t\tif (!Array.isArray(names)) { return; }\n\t\tfor (const n of names) {\n\t\t\tif (!n) { continue; }\n\t\t\taddEvent(n, (...p) => events(n, ...p));\n\t\t}\n\t\treturn;\n\t}\n\tif (typeof events !== 'object') { return; }\n\tfor (const k of Object.keys(events)) {\n\t\tconst f = events[k];\n\t\tif (typeof f !== 'function') { continue; }\n\t\taddEvent(k, f);\n\t}\n\n}\n\nexport default class EventEmitter<\n\tT extends Record<string, any[]> = Record<string, any[]>\n> {\n\tstatic update<T extends Record<string, any[]>>(\n\t\temitter: EventEmitter<T>,\n\t\tevents: any,\n\t): (() => void)[] {\n\t\tif (!events) { return []; }\n\t\tconst newHandles: (() => void)[] = [];\n\t\tif (events && typeof events === 'object') {\n\t\t\tfor (const n of Object.keys(events)) {\n\t\t\t\tif (!n) { continue; }\n\t\t\t\tconst fn = events[n];\n\t\t\t\tif (typeof fn !== 'function') { continue; }\n\t\t\t\tnewHandles.push(emitter.on(n, fn));\n\t\t\t}\n\t\t}\n\t\treturn newHandles;\n\t}\n\tstatic updateInProps<T extends Record<string, any[]>>(\n\t\temitter: EventEmitter<T>,\n\t\tprops: any,\n\t\tcustom?: (addEvent: AddEvent<T>) => void,\n\t): (() => void)[] {\n\t\tif (!props) { return []; }\n\t\n\t\tconst newHandles: (() => void)[] = [];\n\n\t\tfunction addEvent<N extends keyof T>(\n\t\t\tentName: N,\n\t\t\tlistener: (...p: T[N]) => void,\n\t\t): void {\n\t\t\tnewHandles.push(emitter.on(entName, listener));\n\t\t}\n\t\tfor (const k of Object.keys(props)) {\n\t\t\tconst fn = props[k];\n\t\t\tif (typeof fn !== 'function') { continue; }\n\t\t\tconst entName = getEventName(k);\n\t\t\tif (!entName) { continue; }\n\t\t\taddEvent(entName, fn);\n\t\t}\n\t\taddEventFromCollection(addEvent, props['@']);\n\t\taddEventFromCollection(addEvent, props['n:on']);\n\t\taddEventFromCollection(addEvent, props['n-on']);\n\t\tif (typeof custom === 'function') {\n\t\t\tcustom(addEvent);\n\t\t}\n\t\tnewHandles.push(...EventEmitter.update(emitter, props['@']));\n\t\treturn newHandles;\n\t}\n\n\tprivate _names: (keyof T)[] = [];\n\tprivate readonly _cancelHandles = new Set<() => void>();\n\tget names(): (keyof T)[] {\n\t\treturn this._names;\n\t}\n\treadonly emit: Emit<T>;\n\treadonly on: On<T>;\n\tconstructor() {\n\t\tconst events: Record<keyof T, Set<Function>> = Object.create(null);\n\t\tconst names = this._names;\n\n\t\tfunction createEmit(\n\t\t\t...omitNames: (string | number | symbol)[]\n\t\t): Emit<T> {\n\t\t\tfunction emit<N extends keyof T>(name: N, ...p: T[N]): void {\n\t\t\t\tconst event = events[name];\n\t\t\t\tif (!event) { return; }\n\t\t\t\tfor (const fn of [...event]) { \n\t\t\t\t\tfn(...p);\n\t\t\t\t}\n\t\t\t}\n\t\t\temit.omit = (...names: string[]) =>\n\t\t\t\tcreateEmit(...omitNames, ...names);\n\t\t\tReflect.defineProperty(emit, 'names', {\n\t\t\t\tget:() => {\n\t\t\t\t\tmonitorable.markRead(createEmit, 'names');\n\t\t\t\t\treturn names.filter(t => !omitNames.includes(t));\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t});\n\t\t\treturn emit as any as Emit<T>;\n\t\t};\n\t\tconst on: On<T> = (name, listener) => {\n\t\t\tconst fn = monitorable.safeify(listener);\n\t\t\tlet event = events[name];\n\t\t\tif (!event) {\n\t\t\t\tevent = new Set();\n\t\t\t\tevents[name] = event;\n\t\t\t\tmonitorable.markChange(createEmit, 'names');\n\t\t\t\tthis._names = [...this._names, name];\n\t\t\t}\n\t\t\tevent.add(fn);\n\t\t\tlet removed = false;\n\t\t\treturn () => {\n\t\t\t\tif (removed) { return; }\n\t\t\t\tremoved = true;\n\t\t\t\tevent.delete(fn);\n\t\t\t\tif (event.size) { return; }\n\t\t\t\tmonitorable.markChange(createEmit, 'names');\n\t\t\t\tthis._names = this._names.filter(n => n !== name);\n\t\t\t};\n\t\t};\n\t\tthis.emit = createEmit();\n\t\tthis.on = on;\n\t}\n\tupdateHandles(newHandles: (() => void)[]): (() => void)[] {\n\t\tconst eventCancelHandles = this._cancelHandles;\n\t\tconst oldHandles = [...eventCancelHandles];\n\t\teventCancelHandles.clear();\n\t\tfor (const fn of oldHandles) { fn(); }\n\t\tnewHandles.forEach(f => eventCancelHandles.add(f));\n\t\treturn newHandles;\n\t}\n\tupdate(list: any): (() => void)[] {\n\t\tconst handles = EventEmitter.update(this, list);\n\t\treturn this.updateHandles(handles);\n\t}\n\tupdateInProps(\n\t\tlist: any,\n\t\tcustom?: (addEvent: AddEvent<T>) => void,\n\t): (() => void)[] {\n\t\tconst handles = EventEmitter.updateInProps(this, list, custom);\n\t\treturn this.updateHandles(handles);\n\t}\n}\n","export default class NeepError extends Error {\n\treadonly tag: string;\n\tconstructor(message: string, tag: string = '') {\n\t\tsuper(tag ? `[${tag}] ${message}` : message);\n\t\tthis.tag = tag;\n\t}\n}\nexport function assert(v: any, message: string, tag?: string) {\n\tif (v) { return; }\n\tthrow new NeepError(message, tag);\n}\n","import * as monitorableApi from 'monitorable';\nimport { IRender } from './type';\nimport { isProduction } from './constant';\nimport EventEmitter from './EventEmitter';\nimport NeepError, { assert } from './Error';\n\nimport { Devtools } from '../../devtools/src/type';\n\nexport let monitorable: typeof monitorableApi;\n\nexport let value: typeof monitorableApi.value;\nexport let computed: typeof monitorableApi.computed;\nexport let isValue: typeof monitorableApi.isValue;\nexport let encase: typeof monitorableApi.encase;\nexport let recover: typeof monitorableApi.recover;\n\nfunction installMonitorable(api?: typeof monitorableApi) {\n\tif (!api) { return; }\n\tmonitorable = api;\n\tvalue = monitorable.value;\n\tcomputed = monitorable.computed;\n\tisValue = monitorable.isValue;\n\tencase = monitorable.encase;\n\trecover = monitorable.recover;\n}\n\nexport interface InstallOptions {\n\tmonitorable?: typeof monitorableApi;\n\trender?: IRender;\n\trenders?: IRender[];\n\tdevtools?: any;\n}\n\n\nlet nextFrameApi: undefined | ((fn: () => void) => void);\nexport function nextFrame(fn: () => void): void {\n\tassert(nextFrameApi, 'The basic renderer is not installed', 'install');\n\tnextFrameApi!(fn);\n}\n\nexport const renders: Record<string, IRender>\n\t= Object.create(null);\n\nexport function getRender(\n\ttype: string | number | IRender = ''\n\t): IRender {\n\tif (typeof type === 'object') { return type; }\n\treturn renders[type] || renders.default;\n}\n\nfunction addRender(render?: IRender): void {\n\tif (!render) { return; }\n\tif (render.install) {\n\t\trender.install({\n\t\t\tget isValue() { return isValue; },\n\t\t\tEventEmitter,\n\t\t\tError: NeepError,\n\t\t});\n\t}\n\trenders[render.type] = render;\n\tif (nextFrameApi) { return; }\n\tif (!renders.default) {\n\t\trenders.default = render;\n\t}\n\tif (!nextFrameApi && render.nextFrame) {\n\t\trenders.default = render;\n\t\tnextFrameApi = render.nextFrame;\n\t}\n\n}\nfunction installRender({ render, renders}: InstallOptions) {\n\taddRender(render);\n\tif (!Array.isArray(renders)) { return; }\n\tfor (const render of renders) {\n\t\taddRender(render);\n\t}\n}\n\n\nexport const devtools: Devtools = {\n\trenderHook(){},\n};\n\nfunction installDevtools(tools?: Partial<Devtools>) {\n\tif (!tools) { return; }\n\tif (typeof tools !== 'object') { return; }\n\tconst { renderHook } = tools;\n\tif (typeof renderHook === 'function') {\n\t\tdevtools.renderHook = renderHook;\n\t}\n}\n\n\nexport default function install(apis: InstallOptions) {\n\tinstallMonitorable(apis.monitorable);\n\tinstallRender(apis);\n\tif (!isProduction) {\n\t\tinstallDevtools(apis.devtools);\n\t}\n}\n","import { Component } from './type';\n\nexport const components: Record<string, Component> = Object.create(null);\n\nexport function register(name: string, component: Component) {\n\tcomponents[name] = component;\n}\n","export const isElementSymbol = Symbol.for('isNeepElement');\nexport const typeSymbol = Symbol.for('type');\nexport const nameSymbol = Symbol.for('name');\nexport const renderSymbol = Symbol.for('render');\nexport const componentsSymbol = Symbol.for('components');\nexport const configSymbol = Symbol.for('config');\n","import { Component, Render, Marks } from './type';\nimport { nameSymbol, typeSymbol, renderSymbol, componentsSymbol, configSymbol } from './symbols';\n\n/** 组件标记函数 */\nexport interface Mark {\n\t<N extends Component<any, any>>(component: N): N;\n}\n\n/** 创建组件标记函数 */\nfunction Mark<S extends keyof Marks>(\n\tsymbol: S,\n\tvalue: Component[S],\n): Mark {\n\treturn component => {\n\t\tcomponent[symbol] = value as any;\n\t\treturn component;\n\t};\n}\n/** 创建组件标记函数 */\nfunction MarkValue<S extends typeof componentsSymbol | typeof configSymbol>(\n\tsymbol: S,\n\tkey: keyof (NonNullable<Marks[typeof configSymbol]>),\n\tvalue: NonNullable<Marks[typeof componentsSymbol]>[typeof key],\n): Mark {\n\treturn component => {\n\t\tlet obj = component[symbol] as any;\n\t\tif (!obj) {\n\t\t\tobj = Object.create(null);\n\t\t\tcomponent[symbol] = obj;\n\t\t}\n\t\tobj[key] = value;\n\t\treturn component;\n\t};\n}\n\n\n/** 标记组件名称 */\nexport function mName(name: string): Mark;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent: N,\n): N;\nexport function mName<N extends Component<any, any>>(\n\tname: string,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(nameSymbol, name); }\n\tcomponent[nameSymbol] = name;\n\treturn component;\n}\n\n/** 标记组件类型 */\nexport function mType(type?: 'native' | 'simple' | 'standard'): Mark;\nexport function mType<N extends Component<any, any>>(\n\ttype: 'native' | 'simple' | 'standard',\n\tcomponent: N,\n): N;\nexport function mType<N extends Component<any, any>>(\n\ttype?: 'native' | 'simple' | 'standard',\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, type); }\n\tcomponent[typeSymbol] = type;\n\treturn component;\n}\n/** 标记为简单组件 */\nexport function mSimple(): Mark;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mSimple<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'simple'); }\n\tcomponent[typeSymbol] = 'simple';\n\treturn component;\n}\n/** 标记为原生组件 */\nexport function mNative(): Mark;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent: N,\n): N;\nexport function mNative<N extends Component<any, any>>(\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(typeSymbol, 'native'); }\n\tcomponent[typeSymbol] = 'native';\n\treturn component;\n}\n\n/** 标记独立的渲染函数 */\nexport function mRender(fn?: Marks[typeof renderSymbol]): Mark;\nexport function mRender<N extends Component<any, any>>(\n\tfn: Marks[typeof renderSymbol] | undefined,\n\tcomponent: N,\n): N;\nexport function mRender<N extends Component<any, any>>(\n\tfn?: Marks[typeof renderSymbol] | undefined,\n\tcomponent?: N,\n): Mark | N {\n\tif (!component) { return Mark(renderSymbol, fn); }\n\tcomponent[renderSymbol] = fn;\n\treturn component;\n}\n\n/** 标记组件类型 */\nexport function mConfig(name: string, config: any): Mark;\nexport function mConfig<N extends Component<any, any>>(\n\tname: string, config: any,\n\tcomponent: N,\n): N;\nexport function mConfig<N extends Component<any, any>>(\n\tname: string, config: any,\n\tcomponent?: N,\n): Mark | N {\n\tconst mark = MarkValue(configSymbol, name, config);\n\tif (!component) { return mark; }\n\treturn mark(component);\n}\n/** 标记组件类型 */\nexport function mComponent(name: string, item: Component): Mark;\nexport function mComponent<N extends Component<any, any>>(\n\tname: string, item: Component,\n\tcomponent: N,\n): N;\nexport function mComponent<N extends Component<any, any>>(\n\tname: string, item: Component,\n\tcomponent?: N,\n): Mark | N {\n\tconst mark = MarkValue(componentsSymbol, name, item);\n\tif (!component) { return mark; }\n\treturn mark(component);\n}\n\nexport function create<P extends object>(\n\tc: Component<P, never>,\n): Component<P, never>;\nexport function create<\n\tP extends object = object,\n\tR extends object = object,\n>(c: Component<P, R>, r: Render<R>): Component<P, R>;\nexport function create<T extends Component<any, any>>(\n\tc: T,\n\tr?: Render,\n): T {\n\tif (typeof r === 'function') {\n\t\tc[renderSymbol] = r;\n\t}\n\treturn c;\n}\n\nexport function mark<N extends Component<any, any>>(\n\tcomponent: N,\n\t...marks: Mark[]\n): N {\n\tfor (const m of marks) { m(component); }\n\treturn component;\n}\n","import { Component, Context } from '../type';\nimport { value } from '../install';\nimport { mSimple, mark, mName } from '../create';\nimport { Auxiliary } from '../auxiliary';\n\nexport default function lazy<\n\tP extends object = object,\n\tC extends Component<P, any> = Component<P, any>\n>(\n\tcomponent: () => Promise<C | { default: C }>,\n\tPlaceholder?: Component<{ loading: boolean }, any>,\n): Component<P> {\n\tconst reslut = value<0 | 1 | -1>(0);\n\tconst Component = value<undefined | C>(undefined);\n\tasync function load() {\n\t\tif (reslut()) { return; }\n\t\treslut(1);\n\t\ttry {\n\t\t\tconst c = await component();\n\t\t\tif (typeof c === 'function') {\n\t\t\t\tComponent(c);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!c) {\n\t\t\t\treslut(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof c.default === 'function') {\n\t\t\t\tComponent(c.default);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treslut(-1);\n\t\t} catch {\n\t\t\treslut(-1);\n\t\t}\n\t}\n\tfunction Lazy(\n\t\tprops: P,\n\t\t{ childNodes }: Context,\n\t\t{ createElement }: Auxiliary,\n\t) {\n\t\tconst com = Component();\n\t\tif (com) { return createElement(com, props, ...childNodes); }\n\t\tload();\n\t\tif (!Placeholder) { return null; }\n\t\treturn createElement(Placeholder, { loading: reslut() > 0});\n\t}\n\treturn mark(Lazy, mSimple, mName('Lazy'));\n}\n","export const ScopeSlot = 'Neep:ScopeSlot';\nexport const SlotRender = 'Neep:SlotRender';\nexport const Slot = 'Neep:Slot';\nexport const Value = 'Neep:Value';\nexport const Container = 'Neep:Container';\nexport const Deliver = 'Neep:Deliver';\nexport const Template = 'template';\nexport const Fragment = Template;\n","import NeepError from '../Error';\nimport { Entity } from '../type';\n\n/** 当前正在执行的对象 */\nexport let current: Entity | undefined;\nexport function setCurrent<T>(\n\tfn: () => T,\n\tentity: Entity,\n): T {\n\tconst oldEntity = current;\n\tcurrent = entity;\n\ttry {\n\t\tcurrent.$_valueIndex = 0;\n\t\tconst ret = fn();\n\t\tif (current.$_valueIndex !== current.$_values.length) {\n\t\t\tthrow new NeepError(\n\t\t\t\t'Inconsistent number of useValue executions',\n\t\t\t\t'life',\n\t\t\t);\n\t\t}\n\t\treturn ret;\n\t} finally {\n\t\tcurrent = oldEntity;\n\t}\n}\n\nexport function checkCurrent(\n\tname: string,\n\tinitOnly = false,\n): Entity {\n\tif (!current) {\n\t\tthrow new NeepError(\n\t\t\t`Function \\`${name}\\` can only be called within a cycle.`,\n\t\t\t'life',\n\t\t);\n\t}\n\tif (!initOnly) {\n\t\treturn current;\n\t}\n\tif (!current.created) {\n\t\treturn current;\n\t}\n\tthrow new NeepError(\n\t\t`Function \\`${name}\\` can only be called at initialization time.`,\n\t\t'life',\n\t);\n}\n","import { Context, ContextConstructor, Exposed } from '../type';\nimport { monitorable } from '../install';\n\nconst constructors: ContextConstructor[] = [];\nexport function initContext(\n\tcontext: Context,\n\texposed?: Exposed,\n): Context {\n\tfor (const constructor of constructors) {\n\t\tconstructor(context, exposed);\n\t}\n\treturn context;\n}\nexport function addContextConstructor(\n\tconstructor: ContextConstructor\n): void {\n\tconstructors.push(monitorable.safeify(constructor));\n}\n","import { monitorable } from './install';\nimport { Hook, Hooks, Entity } from './type';\nconst hooks: Record<string, Set<Hook>> = Object.create(null);\n\nexport function setHook<H extends Hooks>(\n\tid: H,\n\thook: Hook,\n\tentity?: Entity,\n):() => void;\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n): () => void;\n\nexport function setHook(\n\tid: string,\n\thook: Hook,\n\tentity?: Entity,\n):() => void {\n\tlet list = entity?.$_hooks || hooks;\n\tif (!list) { return () => {}; }\n\thook = monitorable.safeify(hook);\n\tlet set = list[id];\n\tif (!set) {\n\t\tset = new Set();\n\t\tlist[id] = set;\n\t}\n\tset.add(hook);\n\treturn () => set.delete(hook);\n}\n\nexport function callHook<H extends Hooks>(\n\tid: H,\n\texposed: Entity,\n): void;\nexport function callHook(id: string, exposed: Entity): void;\nexport function callHook(id: string, exposed: Entity): void {\n\tif (!exposed) { return; }\n\tfor (const hook of exposed.$_hooks[id] || []) {\n\t\thook(exposed);\n\t}\n\tfor (const hook of hooks[id] || []) {\n\t\thook(exposed);\n\t}\n}\n","/**********************************\n * 组件上下文环境专用 API\n * @description 简单组件不支持\n **********************************/\nimport { Value, WatchCallback } from 'monitorable';\nimport { Hooks } from '../type';\nimport { checkCurrent } from '../helper';\nimport NeepError from '../Error';\nimport { setHook } from '../hook';\nimport { isValue, value, computed } from './state';\n\n\n/**********************************\n * 状态管理类 API\n **********************************/\n/**\n * 监听指定值的变化\n * @description 本质是调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 被监听的值\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: Value<T>,\n\tcb: WatchCallback<T>,\n): () => void;\n/**\n * 监听指定值的变化\n * @description 本质是创建调用 Value 对象的 watch 方法\n * @description 但是通过此方法进行的观察，会在组件生命周期结束时自动停止观察\n * @description 此函数只有在初始化调用时有效\n * @param value 用于计算观测值的函数\n * @param cb    当监听的值发送变化时调用的函数\n */\nexport function watch<T>(\n\tvalue: () => T,\n\tcb: (v: T, stopped: boolean) => void,\n): () => void;\n\nexport function watch<T>(\n\tvalue: Value<T> | (() => T),\n\tcb: (v: Value<T> | T, stopped: boolean) => void\n): () => void {\n\tconst entity = checkCurrent('watch');\n\tif (typeof value !== 'function') { return () => {}; }\n\tconst stop = isValue(value)\n\t\t? value.watch(cb)\n\t\t: computed(value).watch((v, s) => cb(v(), s));\n\tsetHook('beforeDestroy', () => stop(), entity);\n\treturn stop;\n}\n\nexport function useValue(): Value<any>;\nexport function useValue<T>(fn: () => T, name?: string): T;\nexport function useValue<T>(fn?: () => T, name?: string): T | Value<any>;\nexport function useValue<T>(fn?: () => T, name = 'useValue'): T | Value<any> {\n\tconst entity = checkCurrent(name);\n\tconst index = entity.$_valueIndex++;\n\tconst values = entity.$_values;\n\tif (!entity.created) {\n\t\tvalues[index] = undefined;\n\t\tconst v = typeof fn === 'function' ? fn() : value(undefined);\n\t\treturn values[index] = v;\n\t}\n\tif (index >= values.length) {\n\t\tthrow new NeepError(\n\t\t\t'Inconsistent number of useValue executions',\n\t\t\t'life',\n\t\t);\n\t}\n\treturn values[index];\n\n}\n\n/**********************************\n * 钩子类 API\n **********************************/\n/**\n * 为当前组件注册钩子\n * @param name 钩子名称\n * @param hook 钩子\n * @param initOnly 是否仅在初始化时有效\n */\nexport function hook<H extends Hooks>(\n\tname: H,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void);\nexport function hook(\n\tname: string,\n\thook: () => void,\n\tinitOnly?: boolean,\n): undefined | (() => void) {\n\tconst entity = checkCurrent('setHook');\n\tif (initOnly && entity.created) { return undefined; }\n\treturn setHook(name, () => hook(), entity);\n}\n\n/**********************************\n * 配置 API\n **********************************/\n\nfunction setValue<T>(\n\tobj: any,\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tif (\n\t\ttypeof name === 'string'\n\t\t&& ['$', '_'].includes(name[0])\n\t) {\n\t\treturn;\n\t}\n\tif (isValue(value) && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget() { return value(); },\n\t\t\tset(v) { value(v); },\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tif (typeof value === 'function' && opt) {\n\t\tReflect.defineProperty(obj, name, {\n\t\t\tget: value as () => T,\n\t\t\tset: typeof opt === 'function' ? opt : undefined,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t\treturn;\n\t}\n\tReflect.defineProperty(obj, name, {\n\t\tget() { return value; },\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\n\n\n/**\n * 将 Value 导出\n * @param name 导出用的名称\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的导出\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的导出\n * @param name\n * @param getter\n * @param setter\n */\nexport function expose<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function expose<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('expose', true).exposed, name, value, opt);\n}\n\n\n/**\n * 将 Value 传递给子组件\n * @param name 导出用的名称\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: Value<T>,\n\tmix?: boolean,\n): void;\n/**\n * 将普通值导出\n * @param name\n * @param value\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T,\n): void;\n/**\n * 设置基于 getter 的传递\n * @param name\n * @param getter\n * @param nonModifiable\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tnonModifiable: true,\n): void;\n/**\n * 设置基于 getter/setter 的传递\n * @param name\n * @param getter\n * @param setter\n */\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n): void;\nexport function deliver<T>(\n\tname: string | number | symbol,\n\tvalue: T | Value<T> | (() => T),\n\topt?: boolean | ((value: T) => void),\n): void {\n\tsetValue(checkCurrent('deliver', true).delivered, name, value, opt);\n}\n","import { Tag, NeepElement, Component } from '../type';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport * as Tags from './tags';\n\n/**\n * 判读是否为元素\n */\nexport function isElement(v: any): v is NeepElement {\n\tif (!v) { return false; }\n\tif (typeof v !== 'object') { return false; }\n\treturn v[isElementSymbol] === true;\n}\n\nexport function createElement(\n\ttag: Tag,\n\tattrs?: {[key:string]: any},\n\t...children: any[]\n): NeepElement {\n\tattrs = attrs ? {...attrs} : {};\n\tconst node: NeepElement = {\n\t\t[isElementSymbol]: true,\n\t\ttag,\n\t\tchildren: [],\n\t};\n\tif ('key' in attrs) { node.key = attrs.key; }\n\tif ('slot' in attrs) { node.slot = attrs.slot; }\n\tif (typeof attrs.ref === 'function') { node.ref = attrs.ref; }\n\tif (tag === Tags.Value) {\n\t\tnode.value = attrs.value;\n\t\treturn node;\n\t}\n\tnode.children = children;\n\tif (tag === Tags.Template) { return node; }\n\tif (tag === Tags.SlotRender) {\n\t\tnode.render = attrs.render;\n\t\treturn node;\n\t}\n\tif (tag === Tags.ScopeSlot || tag === Tags.Slot) {\n\t\tconst { render, argv, args, name } = attrs;\n\t\tnode.render = render;\n\t\tnode.args = argv && [argv]\n\t\t\t|| Array.isArray(args) && args.length && args\n\t\t\t|| [{}];\n\n\t\tif (tag === Tags.ScopeSlot) {\n\t\t\tnode.props = { name };\n\t\t\treturn node;\n\t\t}\n\t}\n\tnode.props = {};\n\tfor (let k in attrs) {\n\t\tnode.props[k] = attrs[k];\n\t}\n\treturn node;\n}\n\nexport interface elementIteratorOptions {\n\tsimple?: boolean | Component[] | ((c: Component) => boolean);\n}\n\nexport function elements(\n\tnode: any,\n\topt: elementIteratorOptions = {},\n): any[] {\n\tif (Array.isArray(node)) {\n\t\tconst list: any[][] = [];\n\t\tfor (let n of node) {\n\t\t\tlist.push(elements(n, opt));\n\t\t}\n\t\treturn ([] as any[]).concat(...list);\n\t}\n\tif (!isElement(node)) { return [node]; }\n\tlet { tag } = node;\n\tif (!tag) { return []; }\n\n\tif (([Tags.Template, Tags.ScopeSlot] as Tag[]).includes(tag)) {\n\t\treturn elements(node.children, opt);\n\t}\n\tif (typeof tag !== 'function') { return [node]; }\n\tif (tag[typeSymbol] !== 'simple') { return [node]; }\n\tconst { simple } = opt;\n\tif (!simple) { return [node]; }\n\tif (Array.isArray(simple)) {\n\t\tif (simple.includes(tag)) { return [node]; }\n\t} else if (typeof simple === 'function') {\n\t\tif (!simple(tag)) { return [node]; }\n\t}\n\treturn elements(node.children, opt);\n}\n","import { isProduction } from '../constant';\nimport { current } from '../helper';\nimport { setLabel } from '../helper/label';\n\nexport function label(text: string, color = ''): void {\n\tif (!isProduction) {\n\t\tif (!current) {\n\t\t\tsetLabel([text, color]);\n\t\t\treturn;\n\t\t}\n\t\tReflect.defineProperty(current.exposed, '$label', {\n\t\t\tvalue: [text, color],\n\t\t\tconfigurable: true,\n\t\t});\n\t}\n}\n","import * as Constant from '../constant';\nimport * as Tags from './tags';\nimport * as State from './state';\nimport * as Life from './life';\nimport * as Element from './element';\nimport * as Dev from './dev';\n\nexport * from './tags';\nexport * from './state';\nexport * from './life';\nexport * from './element';\nexport * from './dev';\n\nexport { Tags };\n\n/** 辅助 */\nexport interface Auxiliary extends\n\tReadonly<typeof Tags>,\n\tReadonly<typeof State>,\n\tReadonly<typeof Life>,\n\tReadonly<typeof Element>,\n\tReadonly<typeof Dev>,\n\tReadonly<typeof Constant>\n{}\n\nconst auxiliary: Auxiliary = {\n\t...Tags,\n\t...Life,\n\t...Element,\n\t...Dev,\n\t...Constant,\n\tget value() { return State.value; },\n\tget computed() { return State.computed; },\n\tget isValue() { return State.isValue; },\n\tget encase() { return State.encase; },\n\tget recover() { return State.recover; },\n};\n\nexport function setAuxiliary<T>(\n\tname: string,\n\tvalue: T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tvalue,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport function defineAuxiliary<T>(\n\tname: string,\n\tget: (this: Auxiliary) => T,\n): void {\n\tReflect.defineProperty(auxiliary, name, {\n\t\tget,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}\nexport default auxiliary;\n","import { NativeNode } from '../type';\nimport { isProduction } from '../constant';\nimport { MountedNode } from './draw';\n\nlet ids = 0;\nconst Nodes: {[key: number]: MountedNode} = {};\nlet IdMap: undefined | Map<NativeNode, number>;\nif (!isProduction) {\n\tIdMap = new Map();\n}\nexport function createMountedNode(\n\tn: Omit<MountedNode, 'id'>,\n\tid?: number,\n): MountedNode {\n\tif (!isProduction) {\n\t\tid = id || ++ids;\n\t\tconst { node } = n;\n\t\tif (node && IdMap) { IdMap.set(node, id); }\n\t\treturn Nodes[id] = {...n, id};\n\t}\n\treturn {...n, id: 0};\n}\n\nexport function recoveryMountedNode(node: MountedNode): void {\n\tif (!isProduction) {\n\t\tdelete Nodes[node.id];\n\t}\n}\n\nexport function getNode(\n\tid: number | NativeNode,\n): MountedNode | undefined {\n\tif (!isProduction) {\n\t\tif (typeof id !== 'number') {\n\t\t\tid = IdMap?.get(id) || -1;\n\t\t}\n\t\treturn Nodes[id];\n\t}\n\treturn undefined;\n}\n","export interface RecursiveArray<T> extends Array<RecursiveItem<T>>{};\nexport type RecursiveItem<T> = T | RecursiveArray<T>;\n\nexport function *recursive2iterable<T>(\n\tlist: RecursiveItem<T>,\n): Iterable<T> {\n\tif (!Array.isArray(list)) {\n\t\tyield list;\n\t\treturn;\n\t}\n\tfor (const it of list) {\n\t\tyield* recursive2iterable(it);\n\t}\n}\n","import { Tags, Template, isValue } from '../auxiliary';\nimport { IRender, NativeNode, NativeElement, Exposed, Ref } from '../type';\nimport { createMountedNode, recoveryMountedNode } from './id';\nimport { TreeNode } from './convert';\n\n/**\n * @description node / component / children 至少一个有效\n */\nexport interface MountedNode extends TreeNode {\n\tid: number;\n\tparent?: this;\n\tnode: undefined | NativeNode;\n}\n\nlet refList: (() => void)[] | undefined;\nexport function setRefList(list?: (() => void)[]) {\n\trefList = list;\n}\nfunction setRef(\n\tref?: Ref,\n\tnode?: Exposed | NativeNode,\n\tisRemove?: boolean,\n) {\n\tif (typeof ref !== 'function') { return; }\n\tif (!node) { return; }\n\tif (!refList) {\n\t\tref(node, isRemove);\n\t} else {\n\t\trefList.push(() => ref(node, isRemove));\n\t}\n}\n\ntype MountedNodes = MountedNode | MountedNode[]\n\t| (MountedNode | MountedNode[])[];\n\nfunction getLastNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) {\n\t\treturn getLastNode(tree[tree.length - 1]);\n\t}\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getLastNode(component.tree); }\n\treturn getLastNode(children);\n}\n\nfunction getFirstNode(tree: MountedNodes): NativeNode {\n\tif (Array.isArray(tree)) { return getFirstNode(tree[0]); }\n\tconst { component, children, node } = tree;\n\tif (node) { return node; }\n\tif (component) { return getFirstNode(component.tree); }\n\treturn getFirstNode(children[0]);\n}\n\nexport function *getNodes(tree: MountedNodes): Iterable<NativeNode> {\n\tif (Array.isArray(tree)) {\n\t\tfor (const it of tree) {\n\t\t\tyield* getNodes(it);\n\t\t}\n\t\treturn;\n\t}\n\tconst { children, node, component } = tree;\n\tif (node) {\n\t\tyield node;\n\t\treturn;\n\t}\n\tif (component) {\n\t\tyield* getNodes(component.tree);\n\t\treturn;\n\t}\n\tyield* getNodes(children);\n}\n\nexport function unmount(iRender: IRender, tree: MountedNodes): void {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(e => unmount(iRender, e));\n\t\treturn;\n\t}\n\tconst { component, children, node, ref } = tree;\n\trecoveryMountedNode(tree);\n\tif (node) {\n\t\tsetRef(ref, node, true);\n\t\tiRender.remove(node);\n\t\treturn;\n\t}\n\tif (component) {\n\t\tsetRef(ref, component.exposed, true);\n\t\tcomponent.unmount();\n\t\treturn;\n\t}\n\tunmount(iRender, children);\n}\n\n\nfunction replace<T extends MountedNode | MountedNode[]>(\n\tiRender: IRender,\n\tnewTree: T,\n\toldTree: MountedNode | MountedNode[],\n): T {\n\tconst next = getFirstNode(oldTree);\n\tif (!next) { return newTree; }\n\tconst parent = iRender.parent(next);\n\tif (!parent) { return newTree; }\n\tfor (const it of getNodes(newTree)) {\n\t\tiRender.insert(parent, it, next);\n\t}\n\tunmount(iRender, oldTree);\n\treturn newTree;\n}\n\nfunction updateList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n\ttree: MountedNode | MountedNode[],\n): MountedNode[] {\n\tif (!source.length) {\n\t\tconst node = createItem(iRender, {tag: null, children: []});\n\t\treturn [replace(iRender, node, tree)];\n\t}\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: MountedNode[] = [];\n\tconst list = [...tree];\n\tconst mountedMap = new Map<MountedNode, MountedNode>();\n\tfor (const src of source) {\n\t\tconst index = list.findIndex(it =>\n\t\t\tit.tag === src.tag && it.key === src.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tconst old = list[index];\n\t\t\tconst item = updateItem(iRender, src, old);\n\t\t\tmountedMap.set(old, item);\n\t\t\tnewList.push(item);\n\t\t\tlist.splice(index, 1);\n\t\t} else {\n\t\t\tconst item = createItem(iRender, src);\n\t\t\tnewList.push(item);\n\t\t}\n\t}\n\tif (!mountedMap.size) {\n\t\treturn replace(iRender, newList, list);\n\t}\n\tunmount(iRender, list);\n\ttree = tree.filter(t => mountedMap.has(t));\n\tconst last = getLastNode(tree[tree.length - 1]);\n\tconst parent = iRender.parent(last);\n\tif (!parent) { return newList; }\n\tlet next = iRender.next(last);\n\t// 调整次序\n\tfor(let i = newList.length - 1; i >= 0; i--) {\n\t\tconst item = newList[i];\n\t\tconst index = tree.findIndex(o => mountedMap.get(o) === item);\n\t\tif (index >= 0) {\n\t\t\tfor (const it of tree.splice(index)) {\n\t\t\t\tmountedMap.delete(it);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t\tnext = getFirstNode(item) || next;\n\t}\n\treturn newList;\n}\n/**\n * 更新树\n * @param tree 已有树\n * @param source 用于替换的源\n * @param iRender Neep 对象\n */\nfunction updateAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length || 1);\n\tconst list: (MountedNode | MountedNode[])[] = [];\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tlist.push(updateList(iRender, src, tree[index]));\n\t\t} else {\n\t\t\tlist.push(updateItem(iRender, src, tree[index]));\n\t\t}\n\t}\n\tlength = Math.max(source.length, tree.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\tunmount(iRender, tree[index]);\n\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tconst last = getLastNode(list[list.length - 1]);\n\t\tconst parent = iRender.parent(last);\n\t\tconst next = iRender.next(last);\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = source[index];\n\t\t\tconst item = Array.isArray(src)\n\t\t\t\t? createList(iRender, src)\n\t\t\t\t: createItem(iRender, src);\n\t\t\tlist.push(item);\n\t\t\tif (!parent) { continue; }\n\t\t\tfor (const it of getNodes(item)) {\n\t\t\t\tiRender.insert(parent, it, next);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\n/**\n * 更新树节点\n * @param iRender Neep 对象\n * @param tree 已有树\n * @param source 用于替换的源\n */\nfunction updateItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n\ttree: MountedNode | MountedNode[],\n): MountedNode {\n\tif (Array.isArray(tree)) {\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === source.tag && it.component === source.component\n\t\t);\n\t\tif (index < 0) {\n\t\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tunmount(iRender, all);\n\t}\n\tconst { tag, component } = source;\n\tconst ref = source.ref !== tree.ref && source.ref || undefined;\n\tif (tag !== tree.tag || component !== tree.component) {\n\t\treturn replace(iRender, createItem(iRender, source), tree);\n\t}\n\tif (!tag) { return tree; }\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(\n\t\t\t\t\tiRender,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t}, tree.id);\n\t\t}\n\t\tsetRef(ref, component.exposed);\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent,\n\t\t\tchildren: [],\n\t\t}, tree.id);\n\t}\n\tif (tag === Tags.Value) {\n\t\tlet value = source.value;\n\t\tif (isValue(value)) { value = value(); }\n\t\tif(tree.value === value) {\n\t\t\tsetRef(ref, tree.node);\n\t\t\treturn createMountedNode({\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tvalue,\n\t\t\t\tchildren: [],\n\t\t\t}, tree.id);\n\t\t}\n\t\treturn replace(iRender, createValue(iRender, source, value), tree);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: updateAll(\n\t\t\t\tiRender,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t}, tree.id);\n\t}\n\tconst { node } = tree;\n\tiRender.update(\n\t\tnode as NativeElement,\n\t\tsource.props || {},\n\t);\n\tsetRef(ref, node);\n\tif (!source.children.length && !tree.children.length) {\n\t\treturn createMountedNode(\n\t\t\t{\n\t\t\t\t...tree,\n\t\t\t\t...source,\n\t\t\t\tchildren: [],\n\t\t\t},\n\t\t\ttree.id);\n\t}\n\tif (!source.children.length && tree.children.length) {\n\t\tunmount(iRender, tree.children);\n\t}\n\tif (source.children.length && !tree.children.length) {\n\t\tconst children = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node as NativeElement, it);\n\t\t}\n\t\treturn createMountedNode({\n\t\t\t...tree,\n\t\t\t...source,\n\t\t\tchildren,\n\t\t}, tree.id);\n\t}\n\treturn createMountedNode({\n\t\t...tree, ...source,\n\t\tchildren: updateAll(\n\t\t\tiRender,\n\t\t\tsource.children,\n\t\t\ttree.children,\n\t\t),\n\t}, tree.id);\n}\n\nfunction createValue(\n\tiRender: IRender,\n\tsource: TreeNode,\n\tvalue: any,\n): MountedNode {\n\tlet { ref } = source;\n\tif (iRender.isNode(value)) {\n\t\tsetRef(ref, value);\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tvalue,\n\t\t\tnode: value,\n\t\t\tchildren: [],\n\t\t\tcomponent: undefined,\n\t\t});\n\t}\n\tconst type = typeof value;\n\tlet node: NativeNode | undefined;\n\tif (\n\t\ttype === 'bigint'\n\t\t|| type === 'boolean'\n\t\t|| type === 'number'\n\t\t|| type === 'string'\n\t\t|| type === 'symbol'\n\t\t|| value instanceof RegExp\n\t) {\n\t\tnode = iRender.text(String(value));\n\t} else if (value instanceof Date) {\n\t\tnode = iRender.text(value.toISOString());\n\t} else if (type === 'object' && value) {\n\t\tnode = iRender.text(String(value));\n\t\t// TODO: 对象处理\n\t}\n\tif (!node) { node = iRender.placeholder(); }\n\tsetRef(ref, node);\n\treturn createMountedNode({\n\t\t...source,\n\t\tvalue,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t});\n}\n\nfunction createAll(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (!source.length) {\n\t\treturn [createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode: iRender.placeholder(),\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t})];\n\t}\n\n\treturn source.map(item =>\n\t\tArray.isArray(item)\n\t\t\t? createList(iRender, item)\n\t\t\t: createItem(iRender, item)\n\t);\n}\n\nfunction createList(\n\tiRender: IRender,\n\tsource: TreeNode[],\n): MountedNode[] {\n\tif (source.length) {\n\t\treturn source.map(it => createItem(iRender, it));\n\t}\n\treturn [createMountedNode({\n\t\ttag: null,\n\t\tnode: iRender.placeholder(),\n\t\tcomponent: undefined,\n\t\tchildren: [],\n\t})];\n}\n\nfunction createItem(\n\tiRender: IRender,\n\tsource: TreeNode,\n): MountedNode {\n\tconst { tag, ref, component } = source;\n\tif (!tag) {\n\t\tconst node = iRender.placeholder();\n\t\tsetRef(ref, node);\n\t\treturn createMountedNode({\n\t\t\ttag: null,\n\t\t\tnode,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: [],\n\t\t});\n\t}\n\tif (typeof tag !== 'string' || tag === Tags.Container) {\n\t\tif (!component) {\n\t\t\t// TODO: ref\n\t\t\treturn createMountedNode({\n\t\t\t\t...source,\n\t\t\t\tnode: undefined,\n\t\t\t\tcomponent: undefined,\n\t\t\t\tchildren: draw(iRender, source.children),\n\t\t\t});\n\t\t}\n\t\tcomponent.mount();\n\t\tsetRef(ref, component.exposed);\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent, children: [],\n\t\t});\n\t}\n\tif (tag === Tags.Value) {\n\t\tlet value = source.value;\n\t\tif (isValue(value)) { value = value(); }\n\t\treturn createValue(iRender, source, value);\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\t// TODO: ref\n\t\treturn createMountedNode({\n\t\t\t...source,\n\t\t\tnode: undefined,\n\t\t\tcomponent: undefined,\n\t\t\tchildren: createAll(iRender, source.children),\n\t\t});\n\t}\n\tconst node = iRender.create(tag, source.props || {});\n\tsetRef(ref, node);\n\tlet children: (MountedNode | MountedNode[])[] = [];\n\tif (source.children?.length) {\n\t\tchildren = createAll(iRender, source.children);\n\t\tfor (const it of getNodes(children)) {\n\t\t\tiRender.insert(node, it);\n\t\t}\n\t}\n\treturn createMountedNode({\n\t\t...source,\n\t\tnode,\n\t\tcomponent: undefined,\n\t\tchildren,\n\t});\n}\n\nexport default function draw(\n\tiRender: IRender,\n\tsource: (TreeNode | TreeNode[])[],\n\ttree?: (MountedNode | MountedNode[])[],\n): (MountedNode | MountedNode[])[] {\n\tif (tree) {\n\t\treturn updateAll(iRender, source, tree);\n\t}\n\treturn createAll(iRender, source);\n}\n","import { NeepElement, SlotFn, Slots, IRender } from '../type';\nimport { isElement, SlotRender, ScopeSlot } from '../auxiliary';\nimport { isElementSymbol } from '../symbols';\nimport { isProduction } from '../constant';\n\n\nexport function getSlots(\n\tiRender: IRender,\n\tchildren: any[],\n\tslots: Record<string | symbol, any[]>,\n\tnative = false,\n): any[] {\n\t/** 原始对象 */\n\tconst nativeList: any[] = [];\n\tfor (const it of children) {\n\t\tif (Array.isArray(it)) {\n\t\t\tconst list: Record<string | symbol, any[]>\n\t\t\t\t= Object.create(null);\n\t\t\tnativeList.push(getSlots(iRender, it, list, native));\n\t\t\tfor (const k of Reflect.ownKeys(list) as string[]) {\n\t\t\t\tif (k in slots) {\n\t\t\t\t\tslots[k].push(list[k]);\n\t\t\t\t} else {\n\t\t\t\t\tslots[k] = [list[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (native) {\n\t\t\tif (iRender.isNode(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isElement(it)) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (it.tag !== SlotRender) {\n\t\t\t\tnativeList.push(it);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconst slot = isElement(it) && it.slot || 'default';\n\t\tconst el = isElement(it) ? {\n\t\t\t...it, slot: undefined,\n\t\t\tprops: {...it.props, slot: undefined },\n\t\t} : it;\n\t\tif (slot in slots) {\n\t\t\tslots[slot].push(el);\n\t\t} else {\n\t\t\tslots[slot] = [el];\n\t\t}\n\t}\n\treturn nativeList;\n}\nfunction renderSlots(\n\tlist: any[],\n\t...props: any\n): any[] {\n\treturn list.map(it => {\n\t\tif (Array.isArray(it)) {\n\t\t\treturn renderSlots(it, ...props);\n\t\t}\n\t\tif (!isElement(it)) { return it; }\n\t\tif (it.tag !== SlotRender) {\n\t\t\treturn {\n\t\t\t\t...it,\n\t\t\t\tslot: undefined,\n\t\t\t} as NeepElement;\n\t\t}\n\t\tif (typeof it.render === 'function') {\n\t\t\treturn it.render(...props);\n\t\t}\n\t\treturn it.children;\n\t});\n}\nfunction createSlots(\n\tname: string,\n\tlist: any[],\n): SlotFn {\n\tconst slot = (...props: any) => ({\n\t\t[isElementSymbol]: true,\n\t\ttag: ScopeSlot,\n\t\tchildren: renderSlots(list, ...props),\n\t\tinserted: true,\n\t\tlabel: isProduction ? undefined : [`[${name}]`, '#00F'],\n\t} as NeepElement);\n\tslot.children = list;\n\treturn slot;\n}\nexport function setSlots(\n\tchildren: {[key: string]: any[]},\n\tslots: Slots = Object.create(null),\n) {\n\tfor (const k of Reflect.ownKeys(slots)) {\n\t\tif (!(k in children)) {\n\t\t\tdelete slots[k as string];\n\t\t}\n\t}\n\tfor (const k of Reflect.ownKeys(children) as string[]) {\n\t\tslots[k] = createSlots(k, children[k]);\n\t}\n\treturn slots;\n}\n","import { isValue } from '../auxiliary';\nconst disabledKey = new Set([\n\t':', '@', '#', '*',\n\t'!', '%', '^', '~',\n\t'&', '=', '+', '.',\n\t'(', ')', '[', ']', '{', '}', '<', '>',\n]);\nfunction filter(k: string | number | symbol) {\n\tif (typeof k !== 'string') { return true; }\n\tif (disabledKey.has(k[0])) { return false; }\n\tif (/^n[:-]/.test(k)) { return false; }\n\tif (/^on[:-]/.test(k)) { return false; }\n\treturn true;\n}\nexport function updateProps(\n\tobj: any,\n\tprops: any,\n\toldProps: any = {},\n\tdefine = false,\n\tisProps = false,\n) {\n\tconst keys = Reflect.ownKeys(props);\n\tconst newKeys = new Set(isProps ? keys.filter(filter) : keys);\n\tfor (const k of Reflect.ownKeys(obj)) {\n\t\tif (!newKeys.has(k)) {\n\t\t\tdelete obj[k];\n\t\t}\n\t}\n\tif (!define) {\n\t\tfor (const k of newKeys) {\n\t\t\tobj[k] = props[k];\n\t\t}\n\t\treturn obj;\n\t}\n\tfor (const k of newKeys) {\n\t\tconst value = props[k];\n\t\tif (k in oldProps && oldProps[k] === value) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (isValue(value)) {\n\t\t\tReflect.defineProperty(obj, k, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget() { return value(); },\n\t\t\t\tset(v) { value(v); },\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tReflect.defineProperty(obj, k, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue,\n\t\t});\n\t}\n\treturn obj;\n}\n","import {\n\tNeepElement, Exposed, Delivered,\n\tRender, NeepNode, Slots, Context, IRender, Component,\n} from '../type';\nimport { typeSymbol, componentsSymbol } from '../symbols';\nimport { isProduction } from '../constant';\nimport auxiliary, { isElement, Tags } from '../auxiliary';\nimport { renderSymbol, isElementSymbol } from '../symbols';\nimport { getLabel } from '../helper/label';\nimport Entity from './Entity';\nimport { getSlots, setSlots } from './slot';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\nimport EventEmitter from '../EventEmitter';\nimport { components as globalComponents } from '../register';\n\n\nfunction getComponents(\n\t...components: (Record<string, Component> | undefined)[]\n) {\n\treturn components.filter(Boolean) as Record<string, Component>[];\n}\n\nfunction execSimple(\n\tnObject: Entity,\n\tdelivered: Delivered,\n\tnode: NeepElement,\n\ttag: Component,\n\tcomponents: Record<string, Component>[],\n\tchildren: any[],\n) {\n\tconst { iRender } = nObject;\n\tconst slotMap = Object.create(null);\n\tgetSlots(iRender, children, slotMap);\n\tconst slots = setSlots(slotMap);\n\tconst event = new EventEmitter();\n\tevent.updateInProps(node.props);\n\tconst context: Context = initContext({\n\t\tslots,\n\t\tcreated: false,\n\t\tparent: nObject.exposed,\n\t\tdelivered,\n\t\tchildren: new Set<Exposed>(),\n\t\tchildNodes: children,\n\t\trefresh(f) { nObject.refresh(f); },\n\t\temit: event.emit,\n\t});\n\tif (!isProduction) { getLabel(); }\n\tconst result = tag({...node.props}, context, auxiliary);\n\tlet label: [string, string] | undefined;\n\tif (!isProduction) { label = getLabel(); }\n\tconst nodes = exec(nObject, delivered, renderNode(\n\t\tiRender,\n\t\tresult,\n\t\tcontext,\n\t\ttag[renderSymbol],\n\t), slots, getComponents(...components, tag[componentsSymbol]));\n\n\treturn {\n\t\t...node,\n\t\ttag,\n\t\tchildren: Array.isArray(nodes) ? nodes : [nodes],\n\t\tlabel,\n\t} as NeepElement;\n}\n\nfunction execSlot(\n\tnObject: Entity,\n\tdelivered: Delivered,\n\tnode: NeepElement,\n\tslots: Slots,\n\tcomponents: Record<string, Component>[],\n\tchildren: any[],\n\targs: any[] = [{}],\n\tnative: boolean,\n): NeepElement {\n\tconst slotName = node.props?.name || 'default';\n\tconst slot = slots[slotName];\n\tif (typeof slot === 'function') {\n\t\treturn {\n\t\t\t...node,\n\t\t\t...slot(...args),\n\t\t};\n\t}\n\tconst { render } = node;\n\tconst label: [string, string] | undefined = isProduction\n\t\t? undefined\n\t\t: [`[${ slotName }]`, '#00F'];\n\treturn {\n\t\t...node,\n\t\ttag: Tags.ScopeSlot,\n\t\tlabel,\n\t\tchildren: exec(\n\t\t\tnObject,\n\t\t\tdelivered,\n\t\t\ttypeof render !== 'function' ? children : render(...args),\n\t\t\tslots,\n\t\t\tcomponents,\n\t\t\tnative,\n\t\t),\n\t};\n}\n\nfunction findComponent(\n\ttag: any,\n\tcomponents: Record<string, Component>[],\n): Component | string | null {\n\tif (!tag) { return null; }\n\tif (typeof tag !== 'string') { return tag; }\n\tif (tag === 'template') { return tag; }\n\tif (/^neep:.+/i.test(tag)) { return tag; }\n\tfor (const list of components) {\n\t\tconst component = list[tag];\n\t\tif (component) { return component; }\n\t}\n\treturn globalComponents[tag] || tag;\n}\n\nfunction exec(\n\tnObject: Entity,\n\tdelivered: Delivered,\n\tnode: any,\n\tslots: Slots,\n\tcomponents: Record<string, Component>[],\n\tnative = false,\n): any {\n\tif (Array.isArray(node)) {\n\t\treturn node.map(n =>\n\t\t\texec(nObject, delivered, n, slots, components, native)\n\t\t);\n\t}\n\tif (!isElement(node)) { return node; }\n\tconst { inserted, args = [{}] } = node;\n\tlet tag = findComponent(node.tag, components);\n\tif (tag === Tags.Deliver) {\n\t\tconst props = { ...node.props };\n\t\tdelete props.ref;\n\t\tdelete props.slot;\n\t\tdelete props.key;\n\t\tconst newDelivered = Object.create(delivered);\n\t\tupdateProps(newDelivered, props || {}, {}, true);\n\t\treturn {\n\t\t\t...node,\n\t\t\ttag,\n\t\t\t$__neep__delivered: newDelivered,\n\t\t\tchildren: node.children.map(n => exec(\n\t\t\t\tnObject,\n\t\t\t\tnewDelivered,\n\t\t\t\tn,\n\t\t\t\tslots,\n\t\t\t\tcomponents,\n\t\t\t\tnative,\n\t\t\t)),\n\t\t};\n\t}\n\n\tconst children = node.children\n\t\t.map(n => exec(nObject, delivered, n, slots, components, native));\n\n\tif (typeof tag === 'function') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn execSimple(\n\t\t\t\tnObject,\n\t\t\t\tdelivered,\n\t\t\t\tnode,\n\t\t\t\ttag,\n\t\t\t\tcomponents,\n\t\t\t\texec(\n\t\t\t\t\tnObject,\n\t\t\t\t\tdelivered,\n\t\t\t\t\tchildren,\n\t\t\t\t\tslots,\n\t\t\t\t\tcomponents,\n\t\t\t\t\tnative,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\treturn { ...node, $__neep__delivered: delivered, children, tag };\n\n\t}\n\tif (tag === Tags.Slot) {\n\t\ttag = native ? 'slot' : Tags.ScopeSlot;\n\t}\n\tif (tag !== Tags.ScopeSlot || inserted) {\n\t\treturn { ...node, children, tag };\n\t}\n\treturn execSlot(\n\t\tnObject,\n\t\tdelivered,\n\t\t{ ...node, tag },\n\t\tslots,\n\t\tcomponents,\n\t\tchildren,\n\t\targs,\n\t\tnative,\n\t);\n}\n\n\nfunction renderNode<R extends object = object>(\n\tiRender: IRender,\n\tnode: R | NeepNode | NeepNode[] | undefined | null,\n\tcontext: Context,\n\trender?: Render,\n): NeepNode[] {\n\tif (Array.isArray(node)) { return node; }\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\tif (!iRender.isNode(node)\n\t\t&& node && typeof node === 'object' && render\n\t) {\n\t\tnode = render(node, context, auxiliary);\n\t}\n\tif (isElement(node)) { return [node]; }\n\tif (node === undefined || node === null) {\n\t\treturn [{ [isElementSymbol]: true, tag: null, children: [] }];\n\t}\n\treturn [{\n\t\t[isElementSymbol]: true,\n\t\ttag: Tags.Value,\n\t\tvalue: node,\n\t\tchildren: [],\n\t}];\n}\n\nexport default function normalize(\n\tnObject: Entity,\n\tresult: any,\n) {\n\tconst { component } = nObject;\n\treturn exec(\n\t\tnObject,\n\t\tnObject.delivered,\n\t\trenderNode(\n\t\t\tnObject.iRender,\n\t\t\tresult,\n\t\t\tnObject.context,\n\t\t\tcomponent[renderSymbol],\n\t\t),\n\t\tnObject.context.slots,\n\t\tgetComponents(component[componentsSymbol]),\n\t\tBoolean(nObject.native),\n\t);\n}\n","import NeepObject from './Object';\n\nlet delayedRefresh = 0;\nconst objectSet = new Set<NeepObject>();\nexport function wait(obj: NeepObject) {\n\tif (delayedRefresh <= 0) { return false; }\n\tobjectSet.add(obj);\n\treturn true;\n}\nfunction run() {\n\tif (delayedRefresh > 0) { return; }\n\tconst list = [...objectSet];\n\tobjectSet.clear();\n\tlist.forEach(o => o.refresh());\n}\nasync function asyncRefresh<T>(f: () => PromiseLike<T> | T): Promise<T> {\n\ttry {\n\t\tdelayedRefresh++;\n\t\treturn await f();\n\t} finally {\n\t\tdelayedRefresh--;\n\t\trun();\n\t}\n}\nexport default function refresh<T>(f: () => T, async?: false): T;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync: true,\n): Promise<T>;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync?: boolean,\n): PromiseLike<T> | T;\nexport default function refresh<T>(\n\tf: () => PromiseLike<T> | T,\n\tasync?: boolean,\n): PromiseLike<T> | T {\n\tif (async) { return asyncRefresh(f); }\n\ttry {\n\t\tdelayedRefresh++;\n\t\treturn f();\n\t} finally {\n\t\tdelayedRefresh--;\n\t\trun();\n\t}\n}\n","import {\n\tExposed, Delivered,\n\tEntity as ComponentEntity,\n\tNativeComponent,\n\tHook, Hooks, NeepNode, IRender, Component,\n} from '../type';\nimport { callHook, setHook } from '../hook';\nimport { MountedNode } from './draw';\nimport Container from './Container';\nimport convert, { TreeNode } from './convert';\nimport { wait } from './refresh';\nimport { monitorable } from '../install';\nimport EventEmitter from '../EventEmitter';\n\nfunction createExposed(obj: NeepObject): Exposed {\n\tconst cfg: { [K in Exclude<keyof Exposed, '$label'>]-?:\n\t\t{ configurable: true, value: Exposed[K] }\n\t\t| { configurable: true, get(): Exposed[K] }\n\t} = {\n\t\t$parent: { configurable: true, get: () => obj.parent?.exposed },\n\t\t$component: { configurable: true, value: null },\n\t\t$isContainer: { configurable: true, value: false },\n\t\t$created: { configurable: true, get: () => obj.created },\n\t\t$destroyed: { configurable: true, get: () => obj.destroyed },\n\t\t$mounted: { configurable: true, get: () => obj.mounted },\n\t\t$unmounted: { configurable: true, get: () => obj.unmounted },\n\t};\n\tconst exposed: Exposed = Object.create(null, cfg);\n\treturn exposed;\n}\n\nlet completeList: (() => void)[] | undefined;\nexport function setCompleteList(list?: (() => void)[]) {\n\tcompleteList = list;\n}\nexport function complete(it: () => void) {\n\tif (!completeList) {\n\t\tit();\n\t} else {\n\t\tcompleteList.push(it);\n\t}\n}\n\nfunction createEntity(obj: NeepObject): ComponentEntity {\n\tconst cfg: { [K in keyof ComponentEntity]-?:\n\t\t{ configurable: true, value: ComponentEntity[K], writable?: boolean }\n\t\t| { configurable: true, get(): ComponentEntity[K] }\n\t} = {\n\t\texposed: { configurable: true, get: () => obj.exposed },\n\t\tdelivered: { configurable: true, get: () => obj.delivered },\n\t\tparent: { configurable: true, get: () => obj.parent?.entity },\n\t\tcomponent: { configurable: true, value: null },\n\t\tisContainer: { configurable: true, value: false },\n\t\tcreated: { configurable: true, get: () => obj.created },\n\t\tdestroyed: { configurable: true, get: () => obj.destroyed },\n\t\tmounted: { configurable: true, get: () => obj.mounted },\n\t\tunmounted: { configurable: true, get: () => obj.unmounted },\n\t\t$_hooks: { configurable: true, value: Object.create(null) },\n\t\t$_valueIndex: { configurable: true, value: 0, writable: true },\n\t\t$_values: { configurable: true, value: [] },\n\t\tcallHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(h: string) { callHook(h, entity); },\n\t\t},\n\t\tsetHook: {\n\t\t\tconfigurable: true,\n\t\t\tvalue(id: string, hook: Hook) {\n\t\t\t\treturn setHook(id, hook, entity);\n\t\t\t},\n\t\t},\n\t\trefresh: { configurable: true, value: obj.refresh.bind(obj) },\n\t\ton: { configurable: true, value: obj.on },\n\t\temit: { configurable: true, value: obj.emit },\n\t\tconfig: { configurable: true, value: obj.config },\n\t};\n\tconst entity: ComponentEntity = Object.create(null, cfg);\n\treturn entity;\n}\n\nexport default class NeepObject {\n\treadonly events = new EventEmitter();\n\treadonly emit = this.events.emit;\n\treadonly on = this.events.on;\n\treadonly eventCancelHandles = new Set<() => void>();\n\treadonly iRender: IRender;\n\treadonly components: Record<string, Component> = Object.create(null);\n\treadonly config: Record<string, any> = Object.create(null);\n\t/** 接受到的呈递值 */\n\treadonly parentDelivered: Delivered;\n\t/** 向后代呈递的值 */\n\treadonly delivered: Delivered;\n\t/** 组件暴露值 */\n\treadonly exposed: Exposed = createExposed(this);\n\t/** 组件实体 */\n\treadonly entity: ComponentEntity = createEntity(this);\n\t/** 父组件 */\n\tparent?: NeepObject;\n\t/** 原生组件 */\n\tnative: NativeComponent | undefined;\n\t/** 状态 */\n\tcreated: boolean = false;\n\tdestroyed: boolean = false;\n\tmounted: boolean = false;\n\tunmounted: boolean = false;\n\t/**  子组件的暴露值 */\n\treadonly children: Set<Exposed> = new Set();\n\t/** The subtree mounted on the parent node */\n\ttree: (MountedNode | MountedNode[])[] = [];\n\treadonly container: Container;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tparent?: NeepObject,\n\t\tdelivered: Delivered = parent?.delivered || Object.create(null),\n\t\tcontainer?: Container,\n\t) {\n\t\tthis.iRender = iRender;\n\t\tthis.parentDelivered = delivered;\n\t\tthis.delivered = Object.create(delivered);\n\t\tif (parent) {\n\t\t\tthis.parent = parent;\n\t\t}\n\t\tthis.container = container || this as any as Container;\n\t}\n\t/** 结果渲染函数 */\n\tprotected _render: () => NeepNode[] = () => [];\n\n\tget canRefresh(): boolean {\n\t\tif (wait(this)) { return false; }\n\t\treturn !this._delayedRefresh;\n\t}\n\tprotected get needRefresh(): boolean {\n\t\tif (wait(this)) { return false; }\n\t\tif (this._delayedRefresh) { return false; }\n\t\tconst needRefresh = this._needRefresh;\n\t\tthis._needRefresh = false;\n\t\treturn needRefresh;\n\t}\n\t/** 是否需要继续刷新 */\n\tprotected _needRefresh = false;\n\tprivate _delayedRefresh = 0;\n\t/** 是否为刷新中 */\n\tprivate _refreshing = false;\n\t/** 渲染结果 */\n\tprotected _nodes: (TreeNode | TreeNode[])[] = [];\n\tprotected requestDraw() { }\n\tasync asyncRefresh<T>(f: () => PromiseLike<T> | T): Promise<T> {\n\t\ttry {\n\t\t\tthis._delayedRefresh++;\n\t\t\treturn await f();\n\t\t} finally {\n\t\t\tthis._delayedRefresh--;\n\t\t\tthis.refresh();\n\t\t}\n\t}\n\trefresh(): void;\n\trefresh<T>(f: () => T, async?: false): T;\n\trefresh<T>(f: () => PromiseLike<T> | T, async: true): Promise<T>;\n\trefresh<T>(\n\t\tf: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T;\n\trefresh<T>(\n\t\tf?: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T | undefined;\n\trefresh<T>(\n\t\tf?: () => PromiseLike<T> | T,\n\t\tasync?: boolean,\n\t): PromiseLike<T> | T | undefined {\n\t\tif (typeof f === 'function') {\n\t\t\tif (async) { return this.asyncRefresh(f); }\n\t\t\ttry {\n\t\t\t\tthis._delayedRefresh++;\n\t\t\t\treturn f();\n\t\t\t} finally {\n\t\t\t\tthis._delayedRefresh--;\n\t\t\t\tif (this._delayedRefresh <= 0) {\n\t\t\t\t\tthis.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.destroyed) { return; }\n\t\tthis._needRefresh = true;\n\t\tif (!this.created) { return; }\n\n\t\tif (this._refreshing) { return; }\n\t\tthis._refreshing = true;\n\n\t\tlet nodes: NeepNode[] | undefined;\n\t\twhile(this.needRefresh) {\n\t\t\tnodes = this._render();\n\t\t\tif (this.destroyed) { return; }\n\t\t}\n\t\tthis._refreshing = false;\n\t\tif (!this.canRefresh) { return; }\n\t\tif (!nodes) { return; }\n\n\t\tthis._nodes = convert(this, nodes, this._nodes);\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tif (this.unmounted) { return; }\n\t\tthis.requestDraw();\n\t}\n\tcallHook<H extends Hooks>(id: H): void;\n\tcallHook(id: string): void;\n\tcallHook(id: string): void {\n\t\tcallHook(id, this.entity);\n\t}\n\n\tchildNodes: any[] = [];\n\t/** 更新属性及子代 */\n\tprotected _update(props: object, children: any[]): void {\n\t\tthis.childNodes = children;\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: object, children: any[]): void {\n\t\tthis._update(props, children);\n\t}\n\n\n\tprivate __executed_destroy = false;\n\tprivate __executed_mount = false;\n\tprivate __executed_mounted = false;\n\tprotected _destroy() { }\n\tdestroy() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis.__executed_destroy = true;\n\t\tthis.callHook('beforeDestroy');\n\t\tthis._destroy();\n\t\tthis.callHook('destroyed');\n\t\tthis.destroyed = true;\n\t}\n\tprotected _mount() { }\n\tmount() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tif (this.__executed_mount) { return; }\n\t\tthis.__executed_mount = true;\n\t\tthis.callHook('beforeMount');\n\t\tconst result = monitorable.exec(\n\t\t\tc => c && this.requestDraw(),\n\t\t\t() => {\n\t\t\t\tthis._mount();\n\t\t\t\tthis.mounted = true;\n\t\t\t},\n\t\t);\n\t\tthis._cancelDrawMonitor = result.stop;\n\t\tcomplete(() => this.callHook('mounted'));\n\t}\n\tprotected _unmount() { }\n\tunmount() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.__executed_mounted) { return; }\n\t\tthis.__executed_mounted = true;\n\t\tthis.callHook('beforeUnmount');\n\t\tthis._unmount();\n\t\tthis.callHook('unmounted');\n\t\tthis.unmounted = true;\n\t}\n\t_draw() {}\n\t_cancelDrawMonitor?: () => void;\n\tdraw() {\n\t\tif (this.__executed_destroy) { return; }\n\t\tthis._cancelDrawMonitor?.();\n\t\tthis.callHook('beforeUpdate');\n\t\tconst result = monitorable.exec(\n\t\t\tc => c && this.requestDraw(),\n\t\t\t() => this._draw(),\n\t\t);\n\t\tthis._cancelDrawMonitor = result.stop;\n\t\tcomplete(() => this.callHook('updated'));\n\t}\n}\n","import { Component, NeepNode, Slots, Context, Delivered, NativeShadow } from '../type';\nimport auxiliary from '../auxiliary';\nimport { monitorable } from '../install';\nimport { setCurrent } from '../helper/current';\nimport convert, { destroy, TreeNode } from './convert';\nimport draw, { unmount, MountedNode, getNodes } from './draw';\nimport normalize from './normalize';\nimport { getSlots, setSlots } from './slot';\nimport NeepObject from './Object';\nimport { initContext } from '../helper/context';\nimport { updateProps } from './props';\nimport { typeSymbol, configSymbol, componentsSymbol } from '../symbols';\nimport refresh from './refresh';\n\nfunction update(\n\tnObject: Entity<any, any>,\n\tprops: any,\n\tchildren:any[],\n) {\n\tupdateProps(nObject.props, props, {}, false, true);\n\tnObject.events.updateInProps(props);\n\tconst slots = Object.create(null);\n\tconst { native } = nObject;\n\tconst childNodes = getSlots(\n\t\tnObject.iRender,\n\t\tchildren,\n\t\tslots,\n\t\tBoolean(native),\n\t);\n\tsetSlots(slots, nObject.slots);\n\tif (!native) { return; }\n\tnObject.nativeNodes\n\t\t= convert(nObject, childNodes, nObject.nativeNodes);\n\tif (!nObject.mounted) { return; }\n\tnObject.requestDraw();\n}\n\nfunction createContext<\n\tP extends object = object,\n\tR extends object = object\n>(nObject: Entity<P, R>): Context {\n\treturn initContext({\n\t\tslots: nObject.slots,\n\t\tget created() { return nObject.created; },\n\t\tget parent() { return nObject.parent.exposed; },\n\t\tget delivered() { return nObject.parentDelivered; },\n\t\tget children() { return nObject.children; },\n\t\tget childNodes() { return nObject.childNodes; },\n\t\tget emit() { return nObject.emit; },\n\t\trefresh(f) { nObject.refresh(f); },\n\t}, nObject.exposed);\n}\n\n/** 初始化渲染 */\nfunction initRender<R extends object = object>(\n\tnObject: Entity<any, R>\n): { render(): any, nodes: any, stopRender(): void } {\n\tconst {\n\t\tcomponent,\n\t\tprops,\n\t\tcontext,\n\t\tentity,\n\t} = nObject;\n\tconst refresh = (changed: boolean) => changed && nObject.refresh();\n\t// 初始化执行\n\tconst result = monitorable.exec(refresh, () => setCurrent(\n\t\t() => component(props, context, auxiliary),\n\t\tentity,\n\t), { resultOnly: true });\n\tif (typeof result === 'function') {\n\t\t// 响应式\n\t\tconst render = monitorable.createExecutable(\n\t\t\trefresh,\n\t\t\t() => normalize(nObject, (result as () => NeepNode)()),\n\t\t);\n\t\treturn {\n\t\t\tnodes: render(),\n\t\t\trender,\n\t\t\tstopRender: () => render.stop(),\n\t\t};\n\t}\n\n\tconst render = monitorable.createExecutable(\n\t\trefresh,\n\t\t() => normalize(nObject, setCurrent(\n\t\t\t() => component(props, context, auxiliary),\n\t\t\tentity,\n\t\t)),\n\t);\n\treturn {\n\t\tnodes: monitorable.exec(\n\t\t\trefresh,\n\t\t\t() => normalize(nObject, result),\n\t\t\t{ resultOnly: true },\n\t\t),\n\t\trender,\n\t\tstopRender: () => render.stop(),\n\t};\n}\n\n\nexport default class Entity<\n\tP extends object = object,\n\tR extends object = object\n> extends NeepObject {\n\t/** 组件函数 */\n\treadonly component: Component<P, R>;\n\t/** 组件属性 */\n\treadonly props: P = monitorable.encase(Object.create(null));\n\t/** 组件槽 */\n\treadonly slots: Slots = monitorable.encase(Object.create(null));\n\t/** 结果渲染函数 */\n\tprivate readonly _stopRender:() => void;\n\t/** 原生子代 */\n\tnativeNodes: (TreeNode | TreeNode[])[] | undefined;\n\tshadowTree: (MountedNode | MountedNode[])[] = [];\n\tnativeTree: (MountedNode | MountedNode[])[] = [];\n\tprivate readonly _shadow: NativeShadow | undefined;\n\t/** 组件上下文 */\n\treadonly context: Context;\n\treadonly parent: NeepObject;\n\t/** 结果渲染函数 */\n\tconstructor(\n\t\tcomponent: Component<P, R>,\n\t\tprops: object,\n\t\tchildren: any[],\n\t\tparent: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(parent.iRender, parent, delivered, parent.container);\n\t\tthis.component = component;\n\t\tObject.assign(this.config, component[configSymbol]);\n\t\tObject.assign(this.components, component[componentsSymbol]);\n\t\tReflect.defineProperty(\n\t\t\tthis.exposed,\n\t\t\t'$component',\n\t\t\t{ value: component, enumerable: true, configurable: true },\n\t\t);\n\t\t// 原生组件\n\t\t[this.native, this._shadow] =\n\t\t\tcomponent[typeSymbol] === 'native' &&\n\t\t\tthis.iRender.component?.() || [];\n\t\t// 父子关系\n\t\tthis.parent = parent;\n\t\tparent.children.add(this.exposed);\n\t\t// 上下文属性\n\t\tconst context = createContext(this);\n\t\tthis.context = context;\n\t\t// 初始化钩子\n\t\tthis.callHook('beforeCreate');\n\t\t// 更新属性\n\t\tthis.childNodes = children;\n\t\trefresh(() => update(this, props, children));\n\t\t// 获取渲染函数及初始渲染\n\t\tconst { render, nodes, stopRender } = initRender(this);\n\t\tthis._render = render;\n\t\tthis._stopRender = stopRender;\n\t\tthis._nodes = convert(this, nodes);\n\t\t// 初始化钩子\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t\tif (this._needRefresh) { this.refresh(); }\n\t}\n\t/** 更新属性及子代 */\n\t_update(props: object, children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\trefresh(() => update(this, props, children));\n\t}\n\t_destroy() {\n\t\tif (this._stopRender) {\n\t\t\tthis._stopRender();\n\t\t}\n\t\tthis.parent.children.delete(this.exposed);\n\t\tdestroy(this._nodes);\n\t}\n\n\t/** 刷新 */\n\trequestDraw() {\n\t\tthis.container.markDraw(this);\n\t}\n\t_draw() {\n\t\tconst {nativeNodes, iRender, _shadow, native} = this;\n\t\tif (!native || !nativeNodes || !_shadow) {\n\t\t\tthis.tree = draw(\n\t\t\t\tiRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.tree,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tthis.shadowTree = draw(\n\t\t\tiRender,\n\t\t\tthis._nodes,\n\t\t\tthis.shadowTree,\n\t\t);\n\t\tthis.nativeTree = draw(\n\t\t\tiRender,\n\t\t\tnativeNodes,\n\t\t\tthis.nativeTree,\n\t\t);\n\t}\n\t_mount() {\n\t\tconst {nativeNodes, iRender, _shadow, native, _nodes} = this;\n\t\tif (!native || !nativeNodes || !_shadow) {\n\t\t\tthis.tree = draw(iRender, _nodes);\n\t\t\treturn;\n\t\t}\n\t\tthis.tree = draw(iRender, convert(this, native));\n\t\tthis.shadowTree = draw(iRender, _nodes);\n\t\tfor (const it of getNodes(this.shadowTree)) {\n\t\t\tiRender.insert(_shadow, it);\n\t\t}\n\t\tthis.nativeTree = draw(iRender, nativeNodes);\n\t\tfor (const it of getNodes(this.nativeTree)) {\n\t\t\tiRender.insert(native, it);\n\t\t}\n\t}\n\t_unmount() {\n\t\tconst {iRender, nativeTree} = this;\n\t\tunmount(iRender, this.tree);\n\t\tif (!nativeTree) { return; }\n\t\tunmount(iRender, nativeTree);\n\t}\n}\n","import { getRender } from '../install';\nimport { NeepNode, NeepElement, Tag } from '../type';\nimport { Tags, isElement, Value, Template } from '../auxiliary';\nimport { isElementSymbol, typeSymbol } from '../symbols';\nimport { recursive2iterable } from './recursive';\nimport Entity from './Entity';\nimport NeepObject from './Object';\nimport Container from './Container';\nimport { updateProps } from './props';\n\nexport interface TreeNode\n\textends Omit<\n\t\tNeepElement,\n\t\t'children' | 'tag' | typeof isElementSymbol\n\t>\n{\n\t/** 标签名 */\n\ttag: Tag;\n\tchildren: (this | this[])[];\n\tmounted?: boolean;\n\tcomponent?: NeepObject;\n}\n/** 强制转换为 NeepElement */\nfunction toElement(t: any): null | NeepElement {\n\tif (t === false || t === null || t === undefined) {\n\t\treturn null;\n\t}\n\tif (isElement(t)) {\n\t\treturn t;\n\t}\n\treturn {\n\t\t[isElementSymbol]: true,\n\t\ttag: Value,\n\t\tkey: t,\n\t\tvalue: t,\n\t\tchildren: [],\n\t};\n}\n\nexport function destroy(\n\ttree: TreeNode | TreeNode[] | (TreeNode | TreeNode[])[]\n) {\n\tif (Array.isArray(tree)) {\n\t\ttree.forEach(t => destroy(t));\n\t\treturn;\n\t}\n\tconst { component } = tree;\n\tif (component) { component.destroy(); }\n}\n\nfunction createItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n): TreeNode {\n\tif (!source) { return { tag: null, children: [] }; }\n\tconst { tag } = source;\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(nObject, source.children),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Entity(\n\t\t\t\ttag,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\treturn {\n\t\t\t...source, children: [],\n\t\t\tcomponent: new Container(\n\t\t\t\tiRender,\n\t\t\t\tsource.props || {},\n\t\t\t\tsource.children,\n\t\t\t\tnObject,\n\t\t\t\tsource.$__neep__delivered,\n\t\t\t),\n\t\t};\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\treturn {\n\t\t\t...source,\n\t\t\tchildren: convert(nObject, source.children),\n\t\t};\n\t}\n\treturn {...source, children: convert(nObject, source.children) };\n}\n\n/**\n * 更新树节点\n * @param nObject Neep 对象\n * @param source 用于替换的源\n * @param tree 已有树\n */\nfunction updateList(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: TreeNode | TreeNode[],\n): TreeNode[] {\n\tif (!Array.isArray(tree)) { tree = [tree]; }\n\tconst newList: TreeNode[] = [];\n\tfor (const src of recursive2iterable(source)) {\n\t\tconst node = toElement(src);\n\t\tif (!node) { continue; }\n\t\tconst index = tree.findIndex(it =>\n\t\t\tit.tag === node.tag && it.key === node.key\n\t\t);\n\t\tif (index >= 0) {\n\t\t\tnewList.push(updateItem(nObject, node, tree[index]));\n\t\t\ttree.splice(index, 1);\n\t\t} else {\n\t\t\tnewList.push(createItem(nObject, node));\n\t\t}\n\t}\n\tdestroy(tree);\n\treturn newList;\n}\n\n/**\n * 更新树节点\n * @param tree 已有树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n */\nfunction updateItem(\n\tnObject: NeepObject,\n\tsource: NeepNode,\n\ttree?: TreeNode | TreeNode[],\n): TreeNode {\n\tif (!tree) {\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!source) {\n\t\tdestroy(tree);\n\t\treturn { tag: null, children: [] };\n\t}\n\tif (Array.isArray(tree)) {\n\t\tif (!tree.length) { return createItem(nObject, source); }\n\t\tconst index = tree.findIndex(it => it.tag === source.tag);\n\t\tif (index < 0) {\n\t\t\tdestroy(tree);\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tconst all = tree;\n\t\t[tree] = tree.splice(index, 1);\n\t\tdestroy(all);\n\t}\n\tconst { tag } = source;\n\tif (tag !== tree.tag) {\n\t\tdestroy(tree);\n\t\treturn createItem(nObject, source);\n\t}\n\tif (!tag) { return { tag: null, children: [] }; }\n\tif (typeof tag !== 'string') {\n\t\tif (tag[typeSymbol] === 'simple') {\n\t\t\treturn {\n\t\t\t\t...source,\n\t\t\t\tchildren: convert(\n\t\t\t\t\tnObject,\n\t\t\t\t\tsource.children,\n\t\t\t\t\ttree.children,\n\t\t\t\t),\n\t\t\t\tcomponent: undefined,\n\t\t\t};\n\t\t}\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tcomponent.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Container) {\n\t\tconst { component } = tree;\n\t\tif (!component) { return createItem(nObject, source); }\n\t\tconst type = source?.props?.type;\n\t\tconst iRender = type ? getRender(type) : nObject.iRender;\n\t\tif (iRender !== component.iRender) {\n\t\t\treturn createItem(nObject, source);\n\t\t}\n\t\tcomponent.update(source.props || {}, source.children);\n\t\treturn { ...source, children: [], component };\n\t}\n\tif (tag === Tags.Value) {\n\t\treturn { ...source, children: [] };\n\t}\n\tif (tag === Template || tag.substr(0, 5) === 'Neep:') {\n\t\tlet delivered: any;\n\t\tif (Tags.Deliver === tag) {\n\t\t\tconst props = { ...source.props };\n\t\t\tdelete props.ref;\n\t\t\tdelete props.slot;\n\t\t\tdelete props.key;\n\t\t\tdelivered = updateProps(\n\t\t\t\ttree.$__neep__delivered,\n\t\t\t\tprops,\n\t\t\t\ttree.props,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t\treturn {\n\t\t\t...source,\n\t\t\t$__neep__delivered: delivered,\n\t\t\tchildren: convert(\n\t\t\t\tnObject,\n\t\t\t\tsource.children,\n\t\t\t\ttree.children,\n\t\t\t),\n\t\t};\n\t}\n\treturn {\n\t\t...source,\n\t\tchildren: convert(nObject, source.children, tree.children),\n\t};\n}\n\n\nfunction createAll(\n\tnObject: NeepObject,\n\tsource: any[],\n): (TreeNode | TreeNode[])[] {\n\tif (!source.length) { return []; }\n\treturn (source as any[]).map(item => {\n\t\tif (!Array.isArray(item)) {\n\t\t\treturn createItem(nObject, toElement(item));\n\t\t}\n\t\treturn [...recursive2iterable(item)]\n\t\t\t.map(it => createItem(nObject, toElement(it)));\n\t});\n}\nfunction *updateAll(\n\tnObject: NeepObject,\n\tsource: any[],\n\ttree: (TreeNode | TreeNode[])[],\n): Iterable<TreeNode | TreeNode[]> {\n\tlet index = 0;\n\tlet length = Math.min(source.length, source.length);\n\tfor (; index < length; index++) {\n\t\tconst src = source[index];\n\t\tif (Array.isArray(src)) {\n\t\t\tyield updateList(nObject, src, tree[index]);\n\t\t} else {\n\t\t\tyield updateItem(nObject, toElement(src), tree[index]);\n\t\t}\n\t}\n\tlength = Math.max(source.length, source.length);\n\tif (tree.length > length) {\n\t\t\t// 销毁多余项\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tdestroy(tree[index]);\n\t\t\t}\n\t}\n\tif (source.length > length) {\n\t\t// 创建多余项\n\t\tfor (; index < length; index++) {\n\t\t\tconst src = toElement(source[index]);\n\t\t\tif (Array.isArray(src)) {\n\t\t\t\tyield [...recursive2iterable(src)]\n\t\t\t\t\t.map(it => createItem(nObject, it));\n\t\t\t} else {\n\t\t\t\tyield createItem(nObject, src);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * 更新树\n * @param source 用于替换的源\n * @param nObject Neep 对象\n * @param tree 已有树\n */\nfunction convert(\n\tnObject: NeepObject,\n\tsource: any,\n\ttree?: (TreeNode | TreeNode[])[],\n): (TreeNode | TreeNode[])[] {\n\tif (!Array.isArray(source)) { source = [source]; }\n\tif (!tree) {\n\t\treturn createAll(nObject, source);\n\t}\n\treturn [...updateAll(nObject, source, tree)];\n}\n\n\nexport default convert;\n","import {\n\tIRender,\n\tMountProps,\n\tNativeNode,\n\tNativeContainer,\n\tDelivered,\n} from '../type';\nimport { Tags } from '../auxiliary';\nimport { createMountedNode } from './id';\nimport convert, { destroy } from './convert';\nimport draw, { unmount, getNodes, MountedNode, setRefList } from './draw';\nimport NeepObject, { setCompleteList, complete } from './Object';\nimport { nextFrame, monitorable } from '../install';\n\n\nlet awaitDraw = new Set<Container>();\nlet requested = false;\nfunction markDraw(c: Container) {\n\tawaitDraw.add(c);\n\tif (requested) { return; }\n\trequested = true;\n\tnextFrame(() => {\n\t\trequested = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tlist.map(c => c.drawAll());\n\t});\n}\n\nexport default class Container extends NeepObject {\n\tprops: MountProps;\n\t/** 组件树结构 */\n\tcontent: (MountedNode | MountedNode[])[] = [];\n\t_node: NativeNode | null = null;\n\t_container: NativeContainer | null = null;\n\treadonly rootContainer: Container = this;\n\tconstructor(\n\t\tiRender: IRender,\n\t\tprops: MountProps,\n\t\tchildren: any[],\n\t\tparent?: NeepObject,\n\t\tdelivered?: Delivered,\n\t) {\n\t\tsuper(iRender, parent, delivered);\n\t\tthis.props = props;\n\t\tthis.parent = parent;\n\t\tif (parent) {\n\t\t\tthis.rootContainer = parent.container.rootContainer;\n\t\t}\n\t\tthis.callHook('beforeCreate');\n\t\tthis._render = () => children;\n\t\tthis._nodes = convert(this, children);\n\t\tthis.callHook('created');\n\t\tthis.created = true;\n\t}\n\t_drawChildren = false;\n\t_drawContainer = false;\n\tsetChildren(children: any[]): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.childNodes = children;\n\t\tthis._render = () => children;\n\t\tthis._drawChildren = true;\n\t\tthis.refresh();\n\t}\n\tsetProps(props: MountProps): void {\n\t\tif (this.destroyed) { return; }\n\t\tthis.props = props;\n\t\tthis._drawContainer = true;\n\t\tthis.refresh();\n\t}\n\t/** 更新属性及子代 */\n\tupdate(props: MountProps, children: any[]): void {\n\t\tthis.refresh(() => {\n\t\t\tthis.setProps(props);\n\t\t\tthis.setChildren(children);\n\t\t});\n\t}\n\trequestDraw() {\n\t\tthis.markDraw(this);\n\t}\n\t_mount() {\n\t\tconst { props, parent, iRender } = this;\n\t\tconst content = draw(this.container.iRender, this._nodes);\n\t\tthis.content = content;\n\t\tconst [container, node]\n\t\t\t= iRender.mount(props, parent?.iRender);\n\t\tfor (const it of getNodes(content)) {\n\t\t\tiRender.insert(container, it);\n\t\t}\n\t\tthis.tree = [createMountedNode({\n\t\t\ttag: Tags.Value,\n\t\t\tcomponent: undefined,\n\t\t\tnode,\n\t\t\tvalue: node,\n\t\t\tchildren: [],\n\t\t})];\n\t\tthis._node = node;\n\t\tthis._container = container;\n\t}\n\t_destroy() {\n\t\tdestroy(this.content);\n\t}\n\t_unmount() {\n\t\tconst { parent, iRender } = this;\n\t\tif (parent) {\n\t\t\tunmount(parent.iRender, this.tree);\n\t\t}\n\t\tiRender.unmount(\n\t\t\tthis._container!,\n\t\t\tthis._node!,\n\t\t\tBoolean(parent),\n\t\t);\n\t\tunmount(this.iRender, this.content);\n\t}\n\t_draw() {\n\t\tconst {\n\t\t\t_drawChildren: drawChildren,\n\t\t\t_drawContainer: drawContainer,\n\t\t} = this;\n\t\tthis._drawContainer = false;\n\t\tif (drawContainer) {\n\t\t\tthis.iRender.drawContainer(\n\t\t\t\tthis._container!,\n\t\t\t\tthis._node!,\n\t\t\t\tthis.props,\n\t\t\t\tthis.parent?.iRender,\n\t\t\t);\n\t\t}\n\t\tif (this.parent && this.parent.iRender !== this.iRender) {\n\t\t\treturn;\n\t\t}\n\t\tthis._drawChildren = false;\n\t\tif (drawChildren) {\n\t\t\tthis.content = draw(\n\t\t\t\tthis.iRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.content,\n\t\t\t);\n\t\t}\n\t}\n\t_drawSelf() {\n\t\tconst {\n\t\t\t_drawChildren: drawChildren,\n\t\t\t_drawContainer: drawContainer,\n\t\t} = this;\n\t\tthis._needDraw = false;\n\t\tthis._drawChildren = false;\n\t\tthis._drawContainer = false;\n\t\tif (drawContainer) {\n\t\t\tthis.iRender.drawContainer(\n\t\t\t\tthis._container!,\n\t\t\t\tthis._node!,\n\t\t\t\tthis.props,\n\t\t\t\tthis.parent?.iRender,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t\tif (drawChildren) {\n\t\t\tthis.content = draw(\n\t\t\t\tthis.iRender,\n\t\t\t\tthis._nodes,\n\t\t\t\tthis.content,\n\t\t\t);\n\t\t}\n\t}\n\tdrawSelf() {\n\t\tif (!this.mounted) { return; }\n\t\tif (this.destroyed) { return; }\n\t\tthis.callHook('beforeUpdate');\n\t\tmonitorable.exec(\n\t\t\tc => c && this.markDraw(this),\n\t\t\t() => this._drawSelf(),\n\t\t);\n\t\tcomplete(() => this.callHook('updated'));\n\t}\n\t/** 等待重画的项目 */\n\tprivate _awaitDraw = new Set<NeepObject>();\n\t/** 自身是否需要重绘 */\n\tprivate _needDraw = false;\n\t/** 标记需要绘制的元素 */\n\tmarkDraw(\n\t\tnObject: NeepObject,\n\t\tremove = false,\n\t) {\n\t\tif (this.parent?.iRender === this.iRender) {\n\t\t\tthis.parent.container.markDraw(nObject, remove);\n\t\t\treturn;\n\t\t}\n\t\tif (nObject === this && this.parent) {\n\t\t\tthis.parent.container.markDraw(this, remove);\n\t\t\tthis._needDraw = !remove;\n\t\t} else if (remove) {\n\t\t\tthis._awaitDraw.delete(nObject);\n\t\t} else {\n\t\t\tthis._awaitDraw.add(nObject);\n\t\t}\n\t\tthis.rootContainer.markDrawContainer(\n\t\t\tthis,\n\t\t\t!this._needDraw && !this._awaitDraw.size || this.destroyed,\n\t\t);\n\t}\n\tdrawContainer() {\n\t\tconst {\n\t\t\t_node: node,\n\t\t\t_container: container,\n\t\t\t_awaitDraw: awaitDraw,\n\t\t} = this;\n\t\tif (!node || !container) { return; }\n\t\tthis.callHook('beforeDraw');\n\t\tconst needDraw = this._needDraw;\n\t\tthis._needDraw = false;\n\t\tconst list = [...awaitDraw];\n\t\tawaitDraw.clear();\n\t\tif (needDraw) { this.drawSelf(); }\n\t\tlist.map(c => c.draw());\n\t\tthis.iRender.draw(container, node);\n\t\tcomplete(() => this.callHook('drawn'));\n\t}\n\tprivate _containers = new Set<Container>();\n\tmarkDrawContainer(\n\t\tcontainer: Container,\n\t\tremove = false,\n\t) {\n\t\tif (remove) {\n\t\t\tthis._containers.delete(container);\n\t\t} else {\n\t\t\tthis._containers.add(container);\n\t\t}\n\t\tmarkDraw(this);\n\t}\n\tdrawAll() {\n\t\tconst containers = this._containers;\n\t\tif (!containers.size) { return; }\n\t\tthis.callHook('beforeDrawAll');\n\t\tconst refs: (() => void)[] = [];\n\t\tconst completeList: (() => void)[] = [];\n\t\tsetCompleteList(completeList);\n\t\tsetRefList(refs);\n\t\tconst list = [...containers];\n\t\tcontainers.clear();\n\t\tlist.forEach(c => c.drawContainer());\n\t\tsetRefList();\n\t\trefs.forEach(r => r());\n\t\tcompleteList.forEach(r => r());\n\t\tthis.callHook('drawnAll');\n\t}\n}\n","import {\n\tMountProps,\n\tNeepElement,\n\tComponent,\n\tRootExposed,\n} from '../type';\nimport { isElement, createElement } from '../auxiliary';\nimport { isProduction } from '../constant';\nimport { devtools, getRender } from '../install';\nimport Container from './Container';\n\nexport function render(\n\te?: NeepElement | Component,\n\tp: MountProps = {},\n): RootExposed {\n\tlet params = {...p};\n\tconst container =  new Container(\n\t\tgetRender(p.type),\n\t\tparams,\n\t\te === undefined ? [] : isElement(e) ? [e] : [createElement(e)],\n\t);\n\tif (!isProduction) {\n\t\tdevtools.renderHook(container);\n\t}\n\tconst { exposed } = container;\n\tReflect.defineProperty(exposed, '$update', {\n\t\tvalue(c?: NeepElement | Component) {\n\t\t\tcontainer.setChildren(c === undefined ? []\n\t\t\t\t: isElement(c) ? [c] : [createElement(c)]);\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$mount', {\n\t\tvalue(target?: any) {\n\t\t\tif (exposed.$mounted) { return exposed; }\n\t\t\tif (target) {\n\t\t\t\tparams.target = target;\n\t\t\t\tcontainer.setProps(params);\n\t\t\t}\n\t\t\tcontainer.mount();\n\t\t\treturn exposed;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(exposed, '$unmount', {\n\t\tvalue() {\n\t\t\tif (!exposed.$mounted) { return; }\n\t\t\tif (exposed.$unmounted) { return; }\n\t\t\tif (exposed.$destroyed) { return container.destroy(); }\n\t\t\tcontainer.unmount();\n\t\t\treturn;\n\t\t},\n\t\tconfigurable: true,\n\t});\n\tif (params.target) {\n\t\tcontainer.mount();\n\t}\n\treturn exposed as any as RootExposed;\n}\nexport { default as refresh } from './refresh';\n"],"names":["version","mode","isProduction","getEventName","k","substr","test","addEventFromCollection","addEvent","events","Object","keys","f","names","Array","isArray","n","p","EventEmitter","emitter","newHandles","fn","push","on","props","custom","entName","listener","update","this","_names","constructor","Set","create","createEmit","omitNames","emit","name","event","omit","Reflect","defineProperty","get","monitorable","markRead","filter","t","includes","configurable","safeify","markChange","add","removed","delete","size","updateHandles","eventCancelHandles","_cancelHandles","oldHandles","clear","forEach","list","handles","updateInProps","NeepError","Error","message","tag","value","computed","isValue","encase","recover","nextFrameApi","nextFrame","v","assert","renders","getRender","type","default","addRender","render","install","apis","api","installRender","components","register","component","isElementSymbol","Symbol","for","typeSymbol","nameSymbol","renderSymbol","componentsSymbol","configSymbol","Mark","symbol","MarkValue","key","obj","mName","mType","mSimple","mNative","mRender","mConfig","config","mark","mComponent","item","c","r","marks","m","lazy","Placeholder","reslut","Component","undefined","childNodes","createElement","com","load","loading","ScopeSlot","SlotRender","Slot","Value","Container","Deliver","Template","Fragment","current","setCurrent","entity","oldEntity","$_valueIndex","ret","$_values","length","checkCurrent","initOnly","created","constructors","initContext","context","exposed","addContextConstructor","hooks","setHook","id","hook","$_hooks","set","callHook","watch","cb","stop","s","useValue","index","values","setValue","opt","enumerable","expose","deliver","delivered","isElement","attrs","children","node","slot","ref","Tags","argv","args","elements","concat","simple","label","text","color","auxiliary","Life","Element","Dev","Constant","State","setAuxiliary","defineAuxiliary","createMountedNode","recursive2iterable","it","refList","setRefList","setRef","isRemove","getLastNode","tree","getFirstNode","getNodes","unmount","iRender","e","remove","replace","newTree","oldTree","next","parent","insert","updateList","source","createItem","newList","mountedMap","Map","src","findIndex","old","updateItem","splice","last","has","i","o","updateAll","Math","min","max","createList","all","draw","createValue","createAll","isNode","RegExp","String","Date","toISOString","placeholder","map","mount","_source$children","getSlots","slots","native","nativeList","ownKeys","el","renderSlots","createSlots","inserted","setSlots","disabledKey","updateProps","oldProps","define","isProps","newKeys","getComponents","Boolean","findComponent","globalComponents","exec","nObject","newDelivered","$__neep__delivered","slotMap","refresh","result","nodes","renderNode","execSimple","execSlot","normalize","delayedRefresh","objectSet","wait","run","async","asyncRefresh","completeList","setCompleteList","complete","NeepObject","container","cfg","$parent","_obj$parent","$component","$isContainer","$created","$destroyed","destroyed","$mounted","mounted","$unmounted","unmounted","createExposed","_obj$parent2","isContainer","writable","h","bind","createEntity","parentDelivered","_delayedRefresh","needRefresh","_needRefresh","requestDraw","_refreshing","_render","canRefresh","_nodes","convert","_update","_destroy","destroy","__executed_destroy","_mount","__executed_mount","_cancelDrawMonitor","_unmount","__executed_mounted","_draw","nativeNodes","Entity","assign","_shadow","_this$iRender$compone","stopRender","changed","resultOnly","createExecutable","initRender","_stopRender","markDraw","shadowTree","nativeTree","toElement","_source$props","_source$props2","awaitDraw","requested","rootContainer","setChildren","_drawChildren","setProps","_drawContainer","content","_node","_container","drawChildren","drawContainer","_this$parent","_drawSelf","_needDraw","_this$parent2","drawSelf","_awaitDraw","markDrawContainer","needDraw","_containers","drawAll","containers","refs","params","target"],"mappings":"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"}